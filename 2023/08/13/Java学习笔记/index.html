<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习笔记 | 仰望星空时</title><meta name="author" content="KKirito,2021090917010@std.uestc.edu.cn"><meta name="copyright" content="KKirito"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java学习笔记一、基本格式1.类类是Java的基本结构，一个程序可以包含一个或多个类 类的申明： &#x2F;*修饰符class类名&amp;#123;	 程序代码&amp;#125;*&#x2F;public class HelloWorld&amp;#123;            &#x2F;&#x2F;声明一个名为HelloWorld的类&amp;#125;  2.修饰符修饰符用于指定数据、方法、类的属性以及用法 修饰符示例： public class He">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="https://ljqkkirito16.top/2023/08/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="仰望星空时">
<meta property="og:description" content="Java学习笔记一、基本格式1.类类是Java的基本结构，一个程序可以包含一个或多个类 类的申明： &#x2F;*修饰符class类名&amp;#123;	 程序代码&amp;#125;*&#x2F;public class HelloWorld&amp;#123;            &#x2F;&#x2F;声明一个名为HelloWorld的类&amp;#125;  2.修饰符修饰符用于指定数据、方法、类的属性以及用法 修饰符示例： public class He">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/64e18125661c6c8e54c33269.jpg">
<meta property="article:published_time" content="2023-08-13T12:39:44.000Z">
<meta property="article:modified_time" content="2023-08-13T12:39:44.000Z">
<meta property="article:author" content="KKirito">
<meta property="article:tag" content="Markdown">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/64e18125661c6c8e54c33269.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ljqkkirito16.top/2023/08/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-08-13 20:39:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64e18125661c6c8e54c33269.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/64e180ea661c6c8e54c28a1c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="仰望星空时"><span class="site-name">仰望星空时</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-13T12:39:44.000Z" title="发表于 2023-08-13 20:39:44">2023-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-13T12:39:44.000Z" title="更新于 2023-08-13 20:39:44">2023-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">复习资料</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java学习笔记"><a href="#Java学习笔记" class="headerlink" title="Java学习笔记"></a>Java学习笔记</h2><h3 id="一、基本格式"><a href="#一、基本格式" class="headerlink" title="一、基本格式"></a>一、基本格式</h3><h4 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h4><p>类是Java的基本结构，一个程序可以包含一个或多个类</p>
<p>类的申明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修饰符class类名&#123;</span></span><br><span class="line"><span class="comment">	 程序代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;            <span class="comment">//声明一个名为HelloWorld的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2.修饰符"></a>2.修饰符</h4><p>修饰符用于指定数据、方法、类的属性以及用法</p>
<p>修饰符示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;                  <span class="comment">//public修饰为公有的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;     <span class="comment">//static修饰为静态的</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-块"><a href="#3-块" class="headerlink" title="3.块"></a>3.块</h4><p>Java中使用左大括号({)和右大括号(})将语句编组，组中的语句称为代码块或块语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xxxx</span></span><br></pre></td></tr></table></figure>

<h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   xxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注：多行注释中可以嵌套单行注释，但多行注释中不能嵌套多行注释</p>
<h3 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h3><h4 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h4><p>在Java中，整数类型分为字节型（byte）、短整型（short）、整型（int）和长整型（long）四种</p>
<p>在Java中直接给出一个整数值，其默认类型就是int类型。使用中通常有两种情况：</p>
<p>（1）直接将一个在byte在short类型取值范围内的整数值赋给byte或short变量，系统会自动把这个整数当成byte或short类型来处理。</p>
<p>（2）将一个超出int取值范围内的整数值赋给long变量，系统不会自动把这个整数值当成long类型来处理。此时必须声明long类型常量，即在整数值后面添加字母l或L。如果数值未超过int型的取值范围，则可以省略字母l和L。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">99999</span>;          <span class="comment">//所赋的值未超出int取值范围，可以加L，也可省略</span></span><br><span class="line"><span class="type">long</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">9999999999L</span>;      <span class="comment">//所赋的值超出int取值范围，必须加L后缀</span></span><br></pre></td></tr></table></figure>

<h4 id="2-浮点数类型"><a href="#2-浮点数类型" class="headerlink" title="2.浮点数类型"></a>2.浮点数类型</h4><p>在Java中，浮点数分为两种：单精度浮点数（float）和双精度浮点数（double）。</p>
<p>在Java中，使用浮点数数值时，默认的类型是double，在数值后面可加上d或D，作为double类型的标识。在数值后面加上f或F，则作为float类型的识别。若没有加上，Java就会将该数据视为double类型，而在编译时就会发生错误，提示可能会丢失精度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10.0</span>;    <span class="comment">//数值默认为double型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10.0</span>;     <span class="comment">//将丢失精度，错误赋值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span><span class="number">10.0f</span>;     <span class="comment">//正确赋值，给数值添加f后缀，将数值视为float型</span></span><br></pre></td></tr></table></figure>

<h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h4><p>字符型变量用了存储单个字符，字符型值必须使用英文半角格式的单引号”‘“括起来。Java采用char表示字符型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;    <span class="comment">//为一个char类型的变量赋值字符b</span></span><br></pre></td></tr></table></figure>

<h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h4><p>布尔类型的值只有true(真)和false（假）两种,Java的布尔类型用boolean表示，占用1B内存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//声明boolean型变量值为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">//声明boolean型变量值为false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">//不能用非0来代表真，错误</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//不能用0来代表假，错误</span></span><br></pre></td></tr></table></figure>

<h3 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h3><h4 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1.声明变量"></a>1.声明变量</h4><p>声明格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名;</span><br><span class="line">数据类型 变量名<span class="number">1</span>，变量名<span class="number">2</span>,......,变量名n;</span><br></pre></td></tr></table></figure>

<h4 id="2-变量的类型转换"><a href="#2-变量的类型转换" class="headerlink" title="2.变量的类型转换"></a>2.变量的类型转换</h4><p>隐式转换（自动类型转换）：取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再运算。byte、short、char三种类型的数据在运算的时候，都会直接提升为int，然后再进行运算</p>
<p>强制转换：如果把一个取值范围大的数值，赋值给取值范围小的变量，是不允许直接赋值的。如果一定要这么做，就需要加入强制转换。</p>
<p>格式：目标数据类型 变量名 &#x3D; （目标数据类型）被强转的数据</p>
<p>注：强制转换可能出现错误</p>
<h4 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h4><p>变量声明在程序中的位置决定了变量的作用域。变量一定会声明在一对大括号中，该大括号所包含的代码区域就是这个变量的作用域。</p>
<h4 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h4><p>常量是不能被改变的数据。Java程序中使用的直接量称为常量，是在程序中通过源代码直接给出的值，在整个程序执行过程中都不会改变，也称最终量。</p>
<h4 id="5-转义字符"><a href="#5-转义字符" class="headerlink" title="5.转义字符"></a>5.转义字符</h4><ol>
<li>\b,退格键，Unicode码为\u0008</li>
<li>\t,Tab键，Unicode码为\u0009</li>
<li>\n,换行符,Unicode码为\u000A</li>
<li>\r，回车符，Unicode码为\u000D</li>
</ol>
<h4 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h4><h5 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h5><h5 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h5><h5 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3.关系运算符"></a>3.关系运算符</h5><p>&amp;、&amp;&amp;运算符的区别：</p>
<p>都表示与操作，运算符前后的两个操作数皆为true，运算的结果才会为true，否则为flase。两者在使用上有一定的区别：使用&amp;运算符，要求对运算符前后两个操作数都进行判断；而使用&amp;&amp;运算符，当运算符前面的操作数的值为false时，则其后面的操作数将不再判断。</p>
<p>|与||的区别同上。</p>
<h5 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4.位运算符"></a>4.位运算符</h5><p>‘&lt;&lt;’  左移 eg.0000 0001&lt;&lt;2 结果：0000 0100</p>
<p>‘&gt;&gt;’  右移 eg.1000 0100&gt;&gt;2 结果：1110 0001</p>
<p>左移后右边空位补0，左边移出的舍弃；右移同理可得。</p>
<p>‘&gt;&gt;&gt;’ 无符号右移运算符，将操作数的二进制位整体右移指定位数，右移后左边空位补0，右边移出去的舍弃。</p>
<p>进行位移运算遵循如下规则：</p>
<p>（1）对于低于int类型（byte、short和char）的操作数总是先自动转换为int类型后再位移。</p>
<p>（2）对于int类型的位移，当位移数大于int位数32时，Java先用位移数对32求余，得到的余数才是真正的位移数。</p>
<p>（3）对于long类型的位移，当位移数大于long位数64时，Java先用位移数对64求余，得到的余数才是真正的位移数。</p>
<p>但低于int类型的操作数进行无符号位移时，需注意，如果操作数是负数，在自动转换过程中会发生截断，数据丢失，导致位移结果不正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBitOperation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>-<span class="number">12</span>&gt;&gt;&gt;<span class="number">3</span>;   <span class="comment">//对int型无符号右移3位</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">m</span> <span class="operator">=</span>(<span class="type">byte</span>)(a&gt;&gt;&gt;b);   <span class="comment">//对byte类型无符号右移3位</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、程序的结构"><a href="#五、程序的结构" class="headerlink" title="五、程序的结构"></a>五、程序的结构</h3><p>一般来说，程序的结构分为顺序结构、选择结构和循环结构三种，它们都有一个共同的特点是都只有一个入口，也只有一个出口。</p>
<h4 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h4><h4 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h4><p>Java提供了两种分支结构语句：if语句和switch语句。其中，if语句使用布尔表达式或布尔值作为分支条件来进行分支控制；而switch语句用于对多个整数值进行匹配，从而实现多分支控制。</p>
<h5 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            perimeter =<span class="number">2</span>*r*PI;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆半径&quot;</span>+r+<span class="string">&quot;的周长为：&quot;</span>+perimeter);</span><br><span class="line">        r=<span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            area=r*r*PI;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆半径&quot;</span>+r+<span class="string">&quot;的面积为：&quot;</span>+area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-if-else语句"><a href="#2-if-else语句" class="headerlink" title="2.if-else语句"></a>2.if-else语句</h5><h5 id="3-三目运算符"><a href="#3-三目运算符" class="headerlink" title="3.三目运算符"></a>3.三目运算符</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">判断条件？表达式<span class="number">1</span>：表达式<span class="number">2</span>；</span><br></pre></td></tr></table></figure>

<p>当判断条件成立时，执行表达式1，否则将执行表达式2.</p>
<h5 id="4-if-else-if-else语句"><a href="#4-if-else-if-else语句" class="headerlink" title="4.if-else if-else语句"></a>4.if-else if-else语句</h5><p>由于if语句体或else语句体可以是多条语句，所以如果需要在if-else里判断多个条件，可以“随意”嵌套。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式n)&#123;</span><br><span class="line">    语句块n</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句块n+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5.switch语句"></a>5.switch语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">     <span class="keyword">default</span> :</span><br><span class="line">        默认语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用switch语句需注意：</p>
<ol>
<li>switch语句的判定条件只能是byte、short、char和int四种基本类型，JDK5.0开始支持枚举类型，JDK7.0开始支持String类型，不能是boolean类型。</li>
<li>常量1~常量N必须与判断条件类型相同，且为常量表达式，不能是变量。</li>
<li>case字句后面可以有多条语句，这些语句可以使用大括号括起来。</li>
<li>程序将从第一个匹配的case字句处开始执行后面的所有代码（包括后面case字句中的代码）。可以使用break跳出switch语句。</li>
<li>default语句是可选的，当所有case字句条件都不满足时执行。</li>
</ol>
<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h4><p>Java程序设计中引入了循环语句。循环语句共有三种常见的形式：while循环语句、do-while循环语句和for循环语句</p>
<h5 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1.while循环"></a>1.while循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>循环语句也是条件判断语句，用于事先不知道循环次数的情况，其语法格式如下：</span><br><span class="line">    <span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">        循环体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-do-while循环"><a href="#2-do-while循环" class="headerlink" title="2.do-while循环"></a>2.do-while循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure>

<p>do-while语句与while语句还有一个明显的区别是，如果while语句误添加分号，会导致死循环，而do-while的循环条件后面必须有一个分号，用来表明循环结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDoWhile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;1~100的累加和：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(赋初始值;循环条件;迭代语句)&#123;</span><br><span class="line">    语句i;</span><br><span class="line">...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-循环中断"><a href="#4-循环中断" class="headerlink" title="4.循环中断"></a>4.循环中断</h5><h6 id="1-break语句"><a href="#1-break语句" class="headerlink" title="1.break语句"></a>1.break语句</h6><p>注：如果break语句出现在嵌套循环中的内层循环，则break语句只会跳出当前层的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBreak</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>==i)</span><br><span class="line">                <span class="keyword">break</span>;     <span class="comment">//执行该语句将结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在有些场景下，需要从很深的循环中退出时，可以使用带标记的break语句，标记必须break所在循环的外层循环之前定义才有意义，定义在当前循环之前，就失去标记的意义，因为break默认就是结束其所在循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBreakLabel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        label:    <span class="comment">//定义标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;,&quot;</span>+j);</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> label;   <span class="comment">//跳出label标记所标识的循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h6><p>在while、do-while和for语句的循环体中，执行continue语句可以结束本次循环而立即测试循环体的条件，执行下一次循环，但不会终止整个循环</p>
<h3 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h3><p>在一个数组中，数组元素的类型是唯一的，即一个数组中只能存储同一种数据类型的数据，而不能存储多种数据类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义方式<span class="number">1</span>：</span><br><span class="line">数据类型[]数组名；</span><br><span class="line">定义方式<span class="number">2</span>：</span><br><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>

<h4 id="1-数组的初始化"><a href="#1-数组的初始化" class="headerlink" title="1.数组的初始化"></a>1.数组的初始化</h4><p>数组初始化，就是让数组名指向数组对象的过程，该过程主要分为两个步骤：一是对数组名进行初始化，即为数组中的元素分配内存空间和赋值；二是对数组名进行初始化，即将数组名赋值为数组对象的引用。</p>
<h5 id="1-静态初始化"><a href="#1-静态初始化" class="headerlink" title="1.静态初始化"></a>1.静态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：</span><br><span class="line">Int[]array;    <span class="comment">//声明一个int类型的数组</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;；    <span class="comment">//静态初始化数组</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//声明并初始化数组</span></span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line">Int[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//声明并初始化一个int类型的数组</span></span><br></pre></td></tr></table></figure>

<p>其中大括号包含数组元素值，元素值之间用逗号”,”分隔。</p>
<h5 id="2-动态初始化"><a href="#2-动态初始化" class="headerlink" title="2.动态初始化"></a>2.动态初始化</h5><p>动态初始化是指程序员在初始化数组时指定数组的长度，由系统为数组元素分配初始值。</p>
<p>数组动态初始化的具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];    <span class="comment">//动态初始化数组</span></span><br></pre></td></tr></table></figure>

<h4 id="2-数组的常用操作"><a href="#2-数组的常用操作" class="headerlink" title="2.数组的常用操作"></a>2.数组的常用操作</h4><h5 id="1-访问数组"><a href="#1-访问数组" class="headerlink" title="1.访问数组"></a>1.访问数组</h5><p>在Java中，数组对象有一个length属性，用于表示数组的长度</p>
<p>获取数组长度的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.length</span><br></pre></td></tr></table></figure>

<p>接下来用length属性获取数组的长度，具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] list =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];      <span class="comment">//定义一个int类型的数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length;      <span class="comment">//size = 10;数组的长度</span></span><br></pre></td></tr></table></figure>

<h5 id="2-数组元素的存取"><a href="#2-数组元素的存取" class="headerlink" title="2.数组元素的存取"></a>2.数组元素的存取</h5><p>通过操作数组的下标可以访问到数组中的元素，也可以实现数组元素的存取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//声明数组</span></span><br><span class="line">        <span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//存入数组元素</span></span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        a[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">        <span class="comment">//读取数组元素</span></span><br><span class="line">        System.out.print(<span class="string">&quot;数组的元素为：&quot;</span>);</span><br><span class="line">        System.out.println(a[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">3</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从输出结果来看，数组的元素已经存取成功，但数组下标为2、3的位置中并未存入数据，但是却能取到数据为0的元素，可见声明为int类型的数组元素的默认值为0</span></span><br></pre></td></tr></table></figure>

<h5 id="3-数组遍历"><a href="#3-数组遍历" class="headerlink" title="3.数组遍历"></a>3.数组遍历</h5><p>for循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayTraversal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span>&#123;   </span><br><span class="line">        <span class="type">int</span>[] list=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;          <span class="comment">//定义数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.length;i++) &#123;   <span class="comment">//遍历数组元素</span></span><br><span class="line">            System.out.println(list[i]);    <span class="comment">//索引访问数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-数组最大值和最小值"><a href="#4-数组最大值和最小值" class="headerlink" title="4.数组最大值和最小值"></a>4.数组最大值和最小值</h5><h5 id="5-数组排序——冒泡排序法"><a href="#5-数组排序——冒泡排序法" class="headerlink" title="5.数组排序——冒泡排序法"></a>5.数组排序——冒泡排序法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">88</span>,<span class="number">62</span>,<span class="number">12</span>,<span class="number">100</span>,<span class="number">28</span>&#125;;</span><br><span class="line">        <span class="comment">//外层循环控制排序轮数</span></span><br><span class="line">        <span class="comment">//最后一个元素，不用再比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//内层循环控制元素两两比较的次数</span></span><br><span class="line">            <span class="comment">//每轮循环沉底一个元素，沉底元素不用再参加比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较相邻元素</span></span><br><span class="line">                <span class="keyword">if</span> (array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//交换元素</span></span><br><span class="line">                    <span class="type">int</span> tmp=array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印每轮排序结果</span></span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮排序：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                System.out.print(array[j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;最终排序： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3.二维数组"></a>3.二维数组</h4><p>二维数组的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][]array;</span><br><span class="line"><span class="type">int</span> array[][];</span><br></pre></td></tr></table></figure>

<p>二维数组的动态初始化示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];      <span class="comment">//动态初始化3×2的二维数组</span></span><br><span class="line">array[<span class="number">0</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;           <span class="comment">//初始化二维数组的第一个元素</span></span><br><span class="line">array[<span class="number">1</span>]=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;           <span class="comment">//初始化二维数组的第二个元素</span></span><br><span class="line">array[<span class="number">2</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;           <span class="comment">//初始化二维数组的第三个元素</span></span><br></pre></td></tr></table></figure>

<p>二维数组的静态初始化示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-锯齿数组"><a href="#4-锯齿数组" class="headerlink" title="4.锯齿数组"></a>4.锯齿数组</h4><p>二维数组中每一行就是一个一维数组，因此，各行的长度就可以不同，这样的数组称为锯齿数组。</p>
<h3 id="七、方法"><a href="#七、方法" class="headerlink" title="七、方法"></a>七、方法</h3><p>方法是一段可重复使用的代码，为执行一个操作组合在一起的语句集合，用于解决特定的问题。</p>
<h4 id="1-方法的定义"><a href="#1-方法的定义" class="headerlink" title="1.方法的定义"></a>1.方法的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名([参数类型 参数名<span class="number">1</span>，参数类型 参数名<span class="number">2</span>，...])&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方法需注意：</p>
<p>(1)修饰符：方法的修饰符较多，有对访问去权限进行限定的，有静态修饰符static，还有最终修饰符final等。</p>
<p>(2)返回值类型：限定返回值的类型。</p>
<p>(3)参数类型：限定调用方法时传入参数的数据类型。</p>
<p>(4)参数名：是一个变量，用于接受调用方法指定类型的值。</p>
<p>(5)return:关键字，用于结束方法以及返回方法指定类型的值。</p>
<p>(6)返回值：被return返回的值，该值返回给调用者。</p>
<p>方法头中声明的变量称为实际参数，简称实参。形参列表是指形参的类型、顺序和数量。方法不需要任何参数，则形参列表为空。</p>
<h4 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用"></a>2.方法的调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">large</span> <span class="operator">=</span> max(<span class="number">3</span>,<span class="number">4</span>);    <span class="comment">//将方法的返回值赋给变量</span></span><br><span class="line">System.out.println(max(<span class="number">3</span>,<span class="number">4</span>));   <span class="comment">//直接打印方法的返回值</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//println方法没有返回值</span></span><br></pre></td></tr></table></figure>

<p>如果方法定义中包含形参，调用时必须提供实参。实参的类型必须与形参的类型兼容，实参顺序必须与形参的顺序一致。实参的值传递给方法的形参，称为值传递，方法内部对形参的修改不影响实参值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;before main\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">        swap(n,m);</span><br><span class="line">        System.out.println(<span class="string">&quot;end main\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before swap\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">        <span class="type">int</span> tmp=n;</span><br><span class="line">        n=m;</span><br><span class="line">        m=tmp;</span><br><span class="line">        System.out.println(<span class="string">&quot;end swap\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">before main	:n=5,m=2</span></span><br><span class="line"><span class="comment">before swap	:n=5,m=2</span></span><br><span class="line"><span class="comment">end swap	:n=2,m=5</span></span><br><span class="line"><span class="comment">end main	:n=5,m=2</span></span><br><span class="line"><span class="comment">说明swap不能交换实参的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3.方法的重载"></a>3.方法的重载</h4><p>方法重载是指方法名称相同，但形参列表不同的方法。调用重载的方法时，Java编译器会根据实参列表寻找最匹配的方法进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.DoublePredicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//调用max(int,int)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3和8的最大值：&quot;</span>+max(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.0和8.0的最大值：&quot;</span>+max(<span class="number">3.0</span>,<span class="number">8.0</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.0、5.0和8.0的最大值:&quot;</span>+max(<span class="number">3.0</span>,<span class="number">5.0</span>,<span class="number">8.0</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3和8.0的最大值：&quot;</span>+max(<span class="number">3</span>,<span class="number">8.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回两个整数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回两个浮点数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> result;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回三个浮点数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2,<span class="type">double</span> num3)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(max(num1,num2),num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但值得一提的是，调用一个方法时，出现两个或多个可能的匹配时，编译器无法判断哪个是最精确的匹配，则会产生编译错误，称为歧义调用。</p>
<h4 id="4-方法的递归"><a href="#4-方法的递归" class="headerlink" title="4.方法的递归"></a>4.方法的递归</h4><p>递归用于解决使用简单循环难以实现的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4的阶乘：&quot;</span>+fact(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算阶乘</span></span><br><span class="line"><span class="comment">        阶乘计算公式：</span></span><br><span class="line"><span class="comment">        0！=1</span></span><br><span class="line"><span class="comment">        n！=n*(n-1)!;n&gt;0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n*fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h3><h4 id="1-面向对象的概念"><a href="#1-面向对象的概念" class="headerlink" title="1.面向对象的概念"></a>1.面向对象的概念</h4><p>面向对象思想是人类最自然的一种思考方式，它将所有预处理的问题抽象为对象，同时了解这些对象具有哪些相应的属性以及如何展示这些对象的行为，以解决这些对象面临的一些实际问题，这样就在程序开发中引入了面向对象设计的概念，面向对象设计实际上就是对现实世界进行建模工作。</p>
<h5 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h5><p>封装是面向对象程序设计的核心思想。它是指将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节，这就是封装的思想。</p>
<p>eg.计算机的主机是由内存条、硬盘、风扇等部件组成，生产厂家把这些部件用一个外壳封装起来组成主机，用户在使用该主机时，无须关心其内部的组成及工作原理。</p>
<h5 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h5><p>继承是面向对象程序设计提高重用性的重要措施。它体现了特殊类与一般类之间的关系，当特殊类包含一般类的所有属性和行为，并且特殊类还可以有自己的属性和行为时，称作特殊类继承了一般类。一般类又称为父类或基类，特殊类又称为子类或派生类。</p>
<p>eg.已经描述了汽车模型这个类的属性和行为，如果需要描述一个小轿车类，只需让小轿车类继承汽车模型类，然后再描述小轿车类特有的属性和行为，而不必再重复描述一些在汽车模型类中已有的属性和行为。</p>
<h5 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h5><p>多态是面向对象程序设计的重要特征。</p>
<p>eg.生活中也有很多多态，如学校的下课铃声响后，有学生去买零食、有学生去打球、有学生在聊天等等。</p>
<h4 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2.类与对象"></a>2.类与对象</h4><p>对象是事物存在的实体，如学生、汽车等。在计算机世界中，面向对象程序设计的思想要以对象来思考问题，首先要将现实世界的实体抽象为对象，然后考虑这个对象具备的属性和行为。</p>
<h5 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1.类的定义"></a>1.类的定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">    属性类型 成员变量名;   <span class="comment">//成员变量（对象属性）</span></span><br><span class="line">    ...</span><br><span class="line">    修饰符 返回值类型 方法名([参数列表])&#123;   <span class="comment">//成员方法(对象行为)</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-对象的创建与使用"><a href="#2-对象的创建与使用" class="headerlink" title="2.对象的创建与使用"></a>2.对象的创建与使用</h5><p>声明对象格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名</span><br></pre></td></tr></table></figure>

<p>初始化类，Java使用new关键字来创建对象，也称为实例化对象，其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>访问对象的成员变量和成员方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//实例化第一个Person对象</span></span><br><span class="line">        Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//实例化第二个Person对象</span></span><br><span class="line">        p1.name=<span class="string">&quot;张三&quot;</span>;           <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.age=<span class="number">18</span>;                <span class="comment">//调用对象的方法</span></span><br><span class="line">        p1.say();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意的是，一个对象能被多个变量所引用，当对象不被任何变量所引用时，该对象就会成为垃圾，不能再被使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectRef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line">        p1.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        p1.age=<span class="number">18</span>;</span><br><span class="line">        p2.name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        p2.age=<span class="number">28</span>;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1.say();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment">姓名：张三,年龄18</span></span><br><span class="line"><span class="comment">姓名：张三,年龄18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p2被赋值p1后，会断开原有引用的对象，而和p1引用同一对象。因此打印以上内容。此时，p2原有引用的对象不再被任何变量所引用，就成了垃圾对象，不能再被使用，只等待垃圾回收机制进行回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-类的封装"><a href="#3-类的封装" class="headerlink" title="3.类的封装"></a>3.类的封装</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;                  <span class="comment">//声明姓名属性</span></span><br><span class="line">    <span class="type">int</span> age;                     <span class="comment">//声明年龄属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> say&#123;                <span class="comment">//定义显示信息的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();      <span class="comment">//实例化一个Person对象</span></span><br><span class="line">        p1.name = <span class="string">&quot;张三&quot;</span>;           <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.age = -<span class="number">18</span>;              <span class="comment">//为age属性赋值</span></span><br><span class="line">        p1.say();                 <span class="comment">//调用对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免外界随意访问类中的属性，就需要用到封装，即不让使用者访问类的内部成员。Java中使用private关键字来修饰私有属性，私有属性只能在它所在的类中被访问。但这样做使所有的对象都不能访问这个类中的私有属性。为了让外部使用者访问类中的私有属性，需要提供public关键字修饰的属性访问器，即用于设置属性的setXxx()方法和获取属性的getXxx()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;       <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;          <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String str)</span>&#123;    <span class="comment">//设置属性方法</span></span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;  <span class="comment">//获取属性方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>&amp;&amp;n&lt;<span class="number">200</span>)   <span class="comment">//验证年龄，过滤掉不合理的</span></span><br><span class="line">            age = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;      <span class="comment">//定义显示信息的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;,年龄:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();      <span class="comment">//实例化一个Person对象</span></span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);            <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.setAge(-<span class="number">18</span>);                <span class="comment">//为age属性赋值</span></span><br><span class="line">        p1.say();                      <span class="comment">//调用对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4.访问修饰符"></a>4.访问修饰符</h5><p>Java中的访问修饰符是指能够控制类、成员变量、方法的使用权限的关键字。通常放在语句的最前端。类的访问修饰符只有一个public，属性和方法能够被四个修饰符修饰，分别是：public、private、protected，还有一个默认权限default。</p>
<h6 id="1-公有访问控制符（public）"><a href="#1-公有访问控制符（public）" class="headerlink" title="1.公有访问控制符（public）"></a>1.公有访问控制符（public）</h6><p>对所有类可见，被声明public的类、方法和接口允许被程序中的任何类访问。Java的类是通过包的概念来组织的。包是类的一个松散的集合，处于同一个包中的类可以不需要任何说明方便地相互访问和引用，而对于不同包中的类，则需要导入相应public类所在的包。每个java程序的主类必须是public修饰的类，否则Java解释器将不能运行该类。</p>
<h6 id="2-私有访问控制符-private"><a href="#2-私有访问控制符-private" class="headerlink" title="2.私有访问控制符(private)"></a>2.私有访问控制符(private)</h6><p>私有的，即在同一类内可见。被private修饰的属性或方法被提供了最高的保护级别，只能由该类自身访问或修改，而且不能被任何其他类(包括该类的子类)来获取或引用</p>
<h6 id="3-保护防护控制符-protected"><a href="#3-保护防护控制符-protected" class="headerlink" title="3.保护防护控制符(protected)"></a>3.保护防护控制符(protected)</h6><p>受保护的，即对同一包的类和所有子类可见，可以用来修饰属性、方法，不能修饰类。protected修饰的成员变量可以被3种类所引用：该类自身、与它在同一个包中的其他类、在其他包中该类的子类。使用protected修饰符的主要作用是允许其他包中该类的子类来访问父类的特定属性。</p>
<h6 id="4-默认访问控制符（defaulted"><a href="#4-默认访问控制符（defaulted" class="headerlink" title="4.默认访问控制符（defaulted)"></a>4.默认访问控制符（defaulted)</h6><p>默认访问控制权规定，该类只能被同一个包中的类访问和引用，而不可以被其他包中的类使用，这种访问特性又称为包访问性。</p>
<h5 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5.构造方法"></a>5.构造方法</h5><h6 id="1-构造方法的定义"><a href="#1-构造方法的定义" class="headerlink" title="1.构造方法的定义"></a>1.构造方法的定义</h6><p>构造方法是使用new关键字创建一个时被调用的，构造方法时需注意：</p>
<p>(1)构造方法名与类名相同。</p>
<p>(2)构造方法没有返回值类型。</p>
<p>(3)构造方法中不能使用return返回一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person0</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person0</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法自动被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;声明对象：Person p = null&quot;</span>);</span><br><span class="line">        <span class="type">Person0</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//声明对象时不调用构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实例化对象：p=new Person0()&quot;</span>);</span><br><span class="line">        p= <span class="keyword">new</span> <span class="title class_">Person0</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-构造方法的重载"><a href="#2-构造方法的重载" class="headerlink" title="2.构造方法的重载"></a>2.构造方法的重载</h6><p>与普通方法一样，只要每个构造方法的参数列表不同，即可实现重载。</p>
<h4 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3.this关键字"></a>3.this关键字</h4><p>类在定义成员方法时，局部变量和成员变量可以重名，但此时不能访问成员变量。为避免这种情形，Java提供了this关键字，表示当前对象，指向调用的对象本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">equals</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);             <span class="comment">//打印this的地址</span></span><br><span class="line">        System.out.println(p);               <span class="comment">//打印对象地址</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==p)                      <span class="comment">//判断当前对象与this是否相等</span></span><br><span class="line">            System.out.println(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThis</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.equals(p1);</span><br><span class="line">        p2.equals(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this关键字在程序中主要有三种用法，下面分别讲解各种用法。</p>
<h5 id="1-使用this调用类中的属性"><a href="#1-使用this调用类中的属性" class="headerlink" title="1.使用this调用类中的属性"></a>1.使用this调用类中的属性</h5><p>this关键字可以明确调用类的成员变量，不会与局部变量名发生冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person3</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefAttr</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person3</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person3</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法的形参与成员变量同名，使用this明确调用成员变量，避免了与局部变量产生冲突。</span></span><br></pre></td></tr></table></figure>

<h5 id="2-使用this调用成员方法"><a href="#2-使用this调用成员方法" class="headerlink" title="2.使用this调用成员方法"></a>2.使用this调用成员方法</h5><p>this既然可以访问成员变量，那么也可以访问成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">        <span class="built_in">this</span>.log(<span class="string">&quot;Person.say&quot;</span>);   <span class="comment">// 明确使用this调用log()成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefFun</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-使用this调用构造方法"><a href="#3-使用this调用构造方法" class="headerlink" title="3.使用this调用构造方法"></a>3.使用this调用构造方法</h5><p>构造方法是在实例化时被自动调用的，因此不能直接像调用成员方法一样去调用构造方法，但可以使用this（[实参列表]）的方式调用其他的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;       <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person5</span><span class="params">()</span>&#123;   <span class="comment">//这里的Person5()是构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person5</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();    <span class="comment">//此时调用的是没有返回值的Person5类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用有参构造函数&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;   <span class="comment">//明确表示为类中的name属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;    <span class="comment">//明确表示为类中的age属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;,年龄：&quot;</span>+<span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefConstructor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person5</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);  <span class="comment">//调用Person5 含有两个参数的方法</span></span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，在使用this调用构造方法时，还需注意：在构造方法中，使用this调用构造方法的语句必须位于首行，且只能出现一次。</p>
<h4 id="4-static关键字"><a href="#4-static关键字" class="headerlink" title="4.static关键字"></a>4.static关键字</h4><h5 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1.静态变量"></a>1.静态变量</h5><p>使用static修饰的成员变量，称为静态变量或类变量，它被类的所有对象共享，属于整个类所有，因此可以通过类名直接访问。而未使用static修饰的成员变量称为实例变量，它属于具体对象独有，只能通过引用变量访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">//保存对象创建的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInstanceVariable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(p5.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出为1</span></span><br><span class="line"><span class="comment">由于实例变量count是属于类的对象的，对象之间的count是不相关的，它们被存储在不同的内存位置。因此程序运行结果输出的1是引用对象count值。要想实现用count记录类对象被创建的次数，可使用static关键字来修饰成员变量即可达到目的</span></span><br><span class="line"><span class="comment">将第2行代码更换成 static int count;即可实现最后输出5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注：static关键字在修饰变量的时候只能修饰成员变量，不能修饰方法中的局部变量。</p>
<h5 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h5><p>使用static修饰的成员方法，称为静态方法，无须创建类的实例就可以调用静态方法，静态方法可以通过类名调用。</p>
<p>静态方法只能访问类的静态成员（静态变量、静态方法），不能访问类中的实例成员（实例变量和实例方法）。这是因为未被static修饰的成员都是属于对象的，所以需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<h5 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h5><p>代码块是指用”{}”括起来的一段代码，根据位置和声明关键字不同，代码块分为普通、构造、静态、同步四种代码块。</p>
<p>普通代码块就是在方法名或方法体内用大括号”{}”括起来的一段代码。</p>
<p>构造代码块就是直接定义在类中的代码块，它没有任何前缀、后缀及关键字修饰。创建对象时，构造方法被自动调用，构造代码块也是在创建对象时被调用，但它在创造方法之前被调用，因此，构造代码块也可以用来初始化成员变量。另外，构造代码块会优先于构造方法执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Constructor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">()</span>&#123;              <span class="comment">//定义构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;                                  <span class="comment">//定义构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConstructorCodeBlock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块就是使用static关键字修饰的代码块，它是最早执行的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCodeBlock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticCodeBlock</span><span class="params">()</span>&#123;           <span class="comment">//定义构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;                                   <span class="comment">//定义构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;                             <span class="comment">//定义静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticCodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h4><h5 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h5><p>成员内部类是指类作为外部类的一个成员，能直接访问外部类的所有成员，但在外部类中访问内部类，则需要在外部类中创建内部类的对象，使用内部类的对象来访问内部类中的成员。同时，若要在外部类外访问内部类，则需要通过外部类对象去创建内部类对象，在外部类创建一个内部类对象的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 引用变量名 = <span class="keyword">new</span> 外部类名().new 内部类名()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="comment">//定义类成员</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;Other&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">//定义内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Other.Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//内部类成员方法中访问外部类私有成员变量</span></span><br><span class="line">            <span class="comment">//Other.this表示外部类对象</span></span><br><span class="line">            System.out.println(Other.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;:&quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建内部类对象</span></span><br><span class="line">        Other.<span class="type">Inner</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        obj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a>2.静态内部类</h5><p>static关键字修饰的内部类称为静态内部类。静态内部类可以有实例成员和静态成员，它可以直接访问外部类的静态成员，但如果想访问外部类的实例成员，就必须通过外部类的对象去访问。另外，如果在外部类外访问静态内部类成员，则不需要创建外部类对象，只需创建内部类对象即可。</p>
<p>创建内部类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 引用变量名 = <span class="keyword">new</span> 外部类名.内部类名()</span><br></pre></td></tr></table></figure>

<h5 id="3-方法内部类"><a href="#3-方法内部类" class="headerlink" title="3.方法内部类"></a>3.方法内部类</h5><p>在成员方法中定义的类，它与局部变量类似，作用域为定义它的代码块，因此它只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。</p>
<h5 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.匿名内部类</h5><p>匿名内部类就是没有名称的内部类。创建匿名内部类时会创建一个该类的对象，该类定义立即消失，匿名内部类不能重复使用。</p>
<h4 id="6-类的继承"><a href="#6-类的继承" class="headerlink" title="6.类的继承"></a>6.类的继承</h4><h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;</span><br><span class="line">    属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java使用extends关键字指明两个类之间的继承关系。子类继承了父类中的属性和方法，也可以添加新的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> property;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;的年龄&quot;</span>+property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayAge</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;的年龄:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtends</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Child对象</span></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        <span class="comment">//Child对象本身没有name成员变量</span></span><br><span class="line">        <span class="comment">//因为Child父类有name成员变量，所以Child继承了父类的成员变量和方法</span></span><br><span class="line">        c.name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        c.property=<span class="number">100</span>;</span><br><span class="line">        c.age=<span class="number">20</span>;</span><br><span class="line">        c.say();</span><br><span class="line">        c.sayAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Child类通过extends关键字继承了Parent类，继承了其所有的成员，且可以扩展功能。</p>
<p>但Java语言只支持单继承，不允许多重继承，即一个子类只能继承一个父类，否则会引发编译错误。</p>
<p>但它支持多层继承，即一个类的父类可以继承另外的父类。因此，java类可以有无限多个间接父类。</p>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-重写父类方法"><a href="#2-重写父类方法" class="headerlink" title="2.重写父类方法"></a>2.重写父类方法</h5><p>在进行方法重写时必须考虑权限，即被子类重写的方法不能拥有比父类方法更加严格的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父辈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> <span class="keyword">extends</span> <span class="title class_">Parent1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子女&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//闯进Child对象</span></span><br><span class="line">        <span class="type">Child1</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child1</span>();</span><br><span class="line">        c.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：子女 说明重写成功</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>(1)方法的重载是在同一个类中，方法的重写是在子类与父类中。</p>
<p>(2)方法重载要求：方法名相同，参数个数或参数类型不同。</p>
<p>(3)方法重写要求：子类与父类的方法名、返回值类型和参数列表相同。</p>
<h5 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3.super关键字"></a>3.super关键字</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.成员变量</span><br><span class="line"><span class="built_in">super</span>.成员方法([实参列表])</span><br></pre></td></tr></table></figure>

<p>super可以实现调用父类被重写的成员方法，可以在子类中访问被隐藏的父类成员。</p>
<p>子类继承父类时，并没有继承父类的构造方法，但子类构造方法可以调用父类的构造方法。在一个构造方法中调用另一个重组在的构造方法时应使用this关键字，在子类构造方法中调用父类的构造方法时应使用super关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>([参数列表])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父辈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> <span class="keyword">extends</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSuperRefConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Child对象</span></span><br><span class="line">        <span class="type">Child2</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        c.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，如果子类中没有显式地调用父类的构造方法，那么将自动调用父类中不带参数的构造方法。 </p>
<h5 id="4-final关键字"><a href="#4-final关键字" class="headerlink" title="4.final关键字"></a>4.final关键字</h5><p>在Java中，为了考虑安全因素，要求某些类不允许被继承或者不允许被子类修改，这时可以用final关键字修饰。</p>
<p>(1)final修饰的类不能被继承</p>
<p>(2)final修饰的方法不能被子类重写。</p>
<p>(3)final修饰的变量是常量，初始化后不能再修改。</p>
<p>使用final关键字修饰的类称为最终类，表示不能再被其他类继承，如Java中的String类</p>
<p>使用final关键词修饰的方法，称为最终方法，表示子类不能再重写此方法</p>
<p>使用final关键词修饰的变量，称为常量，只能赋值一次。再次对该变量进行赋值时，程序在编译时会报错。</p>
<h4 id="7-抽象类和接口"><a href="#7-抽象类和接口" class="headerlink" title="7.抽象类和接口"></a>7.抽象类和接口</h4><h5 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h5><p>Java中可以定义不含方法体的方法，方法的方法体由该类的子类根据实际需求去实现，这样的方法称为抽象方法，包括抽象方法的类必须是抽象类。</p>
<p>Java中提供了abstract关键字，表示抽象的意思，用abstract修饰的方法，称为抽象方法，是一个不完整的方法，只有方法的声明，没有方法体。用abstract修饰的类，称为抽象类。抽象类可以不包含任何抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用abstract修饰抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="comment">//abstract修饰抽象方法，只有声明，没有实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类不能被实例化，即不能用new关键字创建对象。因此，必须通过子类继承抽象去实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用abstract修饰抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent5</span> &#123;</span><br><span class="line">    <span class="comment">//abstract修饰抽象方法，只有声明，没有实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child5</span> <span class="keyword">extends</span> <span class="title class_">Parent5</span> &#123;</span><br><span class="line">    <span class="comment">//实现抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAbstractClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">            <span class="type">Child5</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child5</span>();</span><br><span class="line">            c.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，具体子类必须实现抽象父类中的所有抽象方法，否则子类必须要声明为抽象类</p>
<p>另外，抽象方法不能用static来修饰，因为static修饰的方法可以通过类名调用，调用将调用一个没有方法体的方法，肯定会出错；抽象方法也不能用final关键字修饰，因为被final关键字修饰的方法不能被重写，而抽象方法的实现需要在子类中实现；抽象方法也饿不能用private关键字修饰，因为子类不能访问带private关键字的抽象方法。</p>
<p>抽象类中可以定义构造方法，因为抽象类仍然使用的是类继承关系，而且抽象类也可以定义成员变量。因此，子类在实例化时必须先对抽象类进行实例化。</p>
<h5 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h5><p>接口是全局常量和公共抽象方法的集合，可被看作一种特殊的类，也属于引用类型。每个接口都被编译成独立的字节码文件。Java提供interface关键字，用于声明接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface接口名&#123;</span><br><span class="line">    全局常量声明</span><br><span class="line">    抽象方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来演示interface关键字的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用interface声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;                  <span class="comment">//等价于public static final String name;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;                   <span class="comment">//等价于public abstract void say();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中定义的变量和方法都包含默认的修饰符，其中定义的变量默认声明为”public static final”，即全局常量。另外，定义的方法默认声明为”public abstract”，即抽象方法。</p>
<h6 id="1-接口的实现"><a href="#1-接口的实现" class="headerlink" title="1.接口的实现"></a>1.接口的实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口列表&#123;</span><br><span class="line">    属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用implements实现两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Parent&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImplements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        c.say();</span><br><span class="line">        c.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 接口名 extends 接口列表&#123;</span><br><span class="line">    全局常量声明</span><br><span class="line">    抽象方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用interface声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用extends继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用implements实现两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterfaceExtend</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">            Child c=<span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">            c.say();</span><br><span class="line">            c.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h4><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在Java中指把类中具有相似功能的不同方法使用同一个方法名实现，从而可以使用相同的方式来调用这些具有不同功能的同名方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Parent类继承Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> <span class="keyword">extends</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Child类实现Parent类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> <span class="keyword">extends</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPolymorphism</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义Person类型引用变量</span></span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//使用Person类型变量引用Parent对象</span></span><br><span class="line">        p=<span class="keyword">new</span> <span class="title class_">Parent2</span>();</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">//使用Person类型变量引用Child对象</span></span><br><span class="line">        p=<span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">//使用Parent类型变量引用Child对象</span></span><br><span class="line">        Parent2 p2=<span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态绑定机制原理是：当调用实例方法时，Java虚拟机从该变量的实际类型开始，沿着继承链向上查找该方法的实现，直到找到为止，并调用首次找到的实现。</p>
<p>对象的类型转换是指可以将一个对象的类型转换成继承结构中的另一种类型。类型转换分两种：</p>
<p>(1)向上转型，是从子类到父类的转换，也称隐式转换。</p>
<p>(2)向下转型，是从父类到子类的转换，也称显示转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Parent类继承Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Child类继承Parent类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTypeCast</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();               <span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">o</span> <span class="operator">=</span> (Parent)p;                 <span class="comment">//向下转型</span></span><br><span class="line">        o.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Object类"><a href="#9-Object类" class="headerlink" title="9.Object类"></a>9.Object类</h4><p>Java中提供一个Object类，是所有类的父亲。如果一个类没有显式地指定继承类，则该类的父类默认为Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在Object类中提供了很多方法</p>
<h5 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1.toString()方法"></a>1.toString()方法</h5><p>调用一个对象的toString()方法会默认返回一个描述该对象的字符串，它由该对象的所属类名、@和对象十六进制形式的内存地址组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> S</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-equals-方法"><a href="#2-equals-方法" class="headerlink" title="2.equals()方法"></a>2.equals()方法</h5><p>equals（）方法是用于测试两个对象是否相等</p>
<p>equals()方法与直接使用&#x3D;&#x3D;运算符检测两个对象结果相同，比较的是地址</p>
<h4 id="10-工厂设计模式"><a href="#10-工厂设计模式" class="headerlink" title="10.工厂设计模式"></a>10.工厂设计模式</h4><h5 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h5><p>简单工厂模式又称静态工厂方法，它的核心是类中包含一个静态方法，该方法用于根据参数来决定返回实现同一接口不同类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义安卓手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Android</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;安卓手机被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义苹果手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iphone</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Iphone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果手机被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">factory</span><span class="params">(String className)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Android&quot;</span>.equals(className))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Iphone&quot;</span>.equals(className))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iphone</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSimpleFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//根据不同的参数生成产品</span></span><br><span class="line">        SimpleFactory.factory(<span class="string">&quot;Android&quot;</span>);</span><br><span class="line">        SimpleFactory.factory(<span class="string">&quot;Iphone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h5><p>工厂方法模式为工厂类定义了接口，用多态来削弱了工厂类的职责</p>
<h5 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h5><p>抽象工厂模式用于意在创建一系列互相关联或互相依赖的对象</p>
<h4 id="11-包"><a href="#11-包" class="headerlink" title="11.包"></a>11.包</h4><h5 id="1-包的定义与使用"><a href="#1-包的定义与使用" class="headerlink" title="1.包的定义与使用"></a>1.包的定义与使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包是Java提供的一种区别类的名字空间的机制，是类的组织方式，是一组相关类和接口的集合，它提供了访问权限和命名的管理机制。</p>
<p>需注意：</p>
<ul>
<li>包名中字母一般都要小写。</li>
<li>包的命名规则：将公司域名反转作为包名</li>
<li>package语句必须是程序代码中的第一行可执行代码</li>
<li>package语句最多只有一句</li>
</ul>
<p>包与文件目录类似，可以分成多级，多级之间用”.”符号进行分隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.1000phone.www;</span><br></pre></td></tr></table></figure>

<p>如果在程序中已声明了包，就必须将编译生成的字节码文件保存到与包名同名的子目录中，可以使用带包编译命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -d .Source.java</span><br></pre></td></tr></table></figure>

<p>其中”-d”表示生成以package定义为准的目录，”.”表示在当前所在的文件夹中生成。编译器会自动在当前目录下建立与包名同名的子目录，并将生成的.class文件自动保存到与包名同名的子目录下。</p>
<h5 id="2-import语句"><a href="#2-import语句" class="headerlink" title="2.import语句"></a>2.import语句</h5><p>import关键字用于导入指定包层次下的某个类或全部类，import语句应放在package语句之后，类定义之前，其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名     <span class="comment">//导入单类</span></span><br><span class="line"><span class="keyword">import</span> 包名.*       <span class="comment">//导入包层次下的全部类</span></span><br></pre></td></tr></table></figure>

<h5 id="3-给Java应用程序打包"><a href="#3-给Java应用程序打包" class="headerlink" title="3.给Java应用程序打包"></a>3.给Java应用程序打包</h5><p>在实际开发中，通常会将一些类提供给别人使用，直接提供字节码文件会比较麻烦，所以一般会将这些类文件打包成jar文件，以供别人使用。jar文件的全称是Java Archive File，意思就是Java归档文件，也称为jar包。将一个jar包添加到classpath环境变量中，Java虚拟机会自动解压jar包，根据包名所对应的目录结构去查找所需的类</p>
<p>通常使用jar命令来打包，可以把一个或多个路径压缩成一个jar文件。jar命令在JDK安装目录下的bin目录中，直接在命令行中输入jar命令，即可查看jar命令的提示信息</p>
<p>jar命令主要参数如下：</p>
<p>(1)c:创建新的文档</p>
<p>(2)v:生成详细的输出信息。</p>
<p>(3)f:指定归档的文件名</p>
<h4 id="12-Lambda表达式"><a href="#12-Lambda表达式" class="headerlink" title="12.Lambda表达式"></a>12.Lambda表达式</h4><p>“-&gt;”可以称作箭头操作符或者Lambda操作符。当使用Lambda表达式进行代码编写的时候就需要使用这个操作符。箭头操作符将Lambda表达式分成左右两部分，在操作符的左侧代表着Lambda表达式的参数列表（接口中抽象方法的参数列表），在操作符的右侧代表着Lambda表达式中所需执行的功能（是对抽象方法的具体实现）Lambda表达式的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters)-&gt;experssion或(parameters) -&gt;&#123;statements;&#125;</span><br></pre></td></tr></table></figure>

<p>上述语法还可以写成：</p>
<p>无参数无返回值：()-&gt;具体实现</p>
<p>有一个参数无返回值:(x)-&gt;具体实现，或x-&gt;具体实现</p>
<p>有多个参数，有返回值，并且Lambda体重有多条语句：（x，y）-&gt;{具体实现}</p>
<p>若方法体只有一条语句，那么大括号和return都可以省略</p>
<h3 id="九-异常"><a href="#九-异常" class="headerlink" title="九.异常"></a>九.异常</h3><p>异常是一个在程序执行期间发生的事件，它中断了正在执行程序的正常指令流。在程序中，错误可能产生于程序员没有预料到各种情况或是超出了程序员可控范围的环境因素，为了保证程序有效地执行，需要对发生的异常进行相应的处理。</p>
<h4 id="1-异常的类型"><a href="#1-异常的类型" class="headerlink" title="1.异常的类型"></a>1.异常的类型</h4><ol>
<li>Error类：Throwable的一个子类，代表错误，该体系描述了Java运行系统中的内部错误以及资源耗尽的情形。该类错误是由Java虚拟机抛出的，如果发生，除了尽力使程序安全退出外，在其他方面是无能为力的。</li>
<li>Exception类是另外一个重要的子类，它规定的异常是程序自身可以处理的异常。异常和错误的区别在于异常是可以被处理的，而错误是不能够被处理的。</li>
</ol>
<h4 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2.异常的处理"></a>2.异常的处理</h4><h5 id="1-使用try-catch处理异常"><a href="#1-使用try-catch处理异常" class="headerlink" title="1.使用try-catch处理异常"></a>1.使用try-catch处理异常</h5><p>异常捕获结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;                 <span class="comment">//捕获异常，该块用于监控可能发生异常的代码块是否发生异常，如果异常发生了   </span></span><br><span class="line">    程序代码<span class="number">1</span>          <span class="comment">//就会将产生的异常类对象抛出，并转向catch中继续执行。</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e1)&#123;      <span class="comment">//处理异常，一个try块后面可以有多个catch块，每个catch块可以处理的异常类型</span></span><br><span class="line">    程序代码<span class="number">2</span>          <span class="comment">//由异常处理器参数指定。</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e2)&#123;</span><br><span class="line">    程序代码<span class="number">3</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;               <span class="comment">//进行最终处理，不管程序是否发生异常最终都会执行的代码块。当包含catch子句</span></span><br><span class="line">    程序代码<span class="number">4</span>           <span class="comment">//时，finally字句是可选的；当包含finally字句时，catch子句是可选的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管程序是否发生异常，还是在try块中使用return语句结束，finally块都会执行。</p>
<h5 id="2-使用throws关键字抛出异常"><a href="#2-使用throws关键字抛出异常" class="headerlink" title="2.使用throws关键字抛出异常"></a>2.使用throws关键字抛出异常</h5><p>如果方法不捕获被检查出的异常，那么方法必须声明它可以抛出的这些异常，用于告知调用者此方法有异常。Java通过throws子句表明方法可抛出的所有异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 方法名(形参列表)<span class="keyword">throws</span> 异常类<span class="number">1</span>,异常类,...,异常类n&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws声明的方法表示此方法不处理异常，而交给方法的调用者进行处理。因此，不管方法是否发生异常，调用者都必须进行异常处理。</p>
<h5 id="3-使用throw关键字抛出异常"><a href="#3-使用throw关键字抛出异常" class="headerlink" title="3.使用throw关键字抛出异常"></a>3.使用throw关键字抛出异常</h5><p>针对用户希望能亲自进行异常类对象的实例化操作，自己手动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常对象();</span><br></pre></td></tr></table></figure>

<h4 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h4><p>在特定的问题领域，可通过扩展Exception类或RuntimeException类来创建自定义的异常。异常类包含和异常相关的信息，这有助于负责捕获异常的catch代码块准确地分析并处理异常。</p>
<p>(1)创建自定义异常类并继承Exception基类，如果自定义Runtime异常，则继承RuntimeException基类</p>
<p>(2)此方法中通过throw关键字抛出异常对象。</p>
<p>(3)如果在当前抛出异常的方法中处理异常，可以使用try-catch语句块捕获并处理，否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</p>
<p>(4)在出现异常方法的调用者中捕获并处理异常。</p>
<h4 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h4><p>断言语句用于确保程序的正确性，以避免逻辑错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> 布尔表达式;</span><br><span class="line"><span class="keyword">assert</span> 布尔表达式:消息;</span><br></pre></td></tr></table></figure>

<p>使用第一种格式，当布尔类型表达式值为false时，抛出AssertionError异常，如果使用第二种格式，则输出错误消息。在默认情况下，断言不起作用，可用-ea选项激活断言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -ea类名</span><br><span class="line">java -ea:包名 -da:类名</span><br></pre></td></tr></table></figure>

<h3 id="十-多线程"><a href="#十-多线程" class="headerlink" title="十.多线程"></a>十.多线程</h3><p>线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为线程，这些线程可以同时存在、同时运行，一个进程可能包含多个同时执行的线程</p>
<p>进程是程序的一次动态执行过程，需要经历从代码加载、代码执行到执行完毕的一个完整过程，这个过程也是进程本身从产生、发展到最终消亡的过程。每个运行中的程序就是一个进程。一般而言，进程在系统中独立存在，拥有自己独立的资源，多个进程可以在单个处理器上并发执行且互不影响。</p>
<p>操作系统可以同时执行多个进程，进程可以同时执行多个任务，其中每个任务就是线程。eg.杀毒软件程序是一个进程，那么它在喂计算机体检的同时可以清理垃圾文件，这就是两个线程同时运行。</p>
<h4 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1.线程的创建"></a>1.线程的创建</h4><h5 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承Thread类创建线程</h5><p>Java提供了Thread类代表线程，它位与java.lang包中</p>
<p>(1)定义Thread类的子类，并重写run()方法，run()方法称为线程执行体。</p>
<p>(2)创建Thread子类的实例，即创建了线程对象。</p>
<p>(3)调用线程对象的start()方法启动线程。</p>
<p>启动一个新线程时，需要创建一个Thread类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread1</span>();         <span class="comment">//创建SubThread1实例</span></span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread1</span>();</span><br><span class="line">        st1.start();                        <span class="comment">//开启线程</span></span><br><span class="line">        st2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;                     <span class="comment">//重写run()方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.current().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h5><p>(1)定义Runnable接口实现类，并重写run()方法</p>
<p>(2)创建Runnable实现类的示例，并将实例对象传给Thread类的target来创建线程对象。</p>
<p>(3)调用线程对象的start()方法启动线程。</p>
<h5 id="3-使用Callable接口和Futrue接口创建线程"><a href="#3-使用Callable接口和Futrue接口创建线程" class="headerlink" title="3.使用Callable接口和Futrue接口创建线程"></a>3.使用Callable接口和Futrue接口创建线程</h5><p>重写run()方法实现功能代码有一定局限性，这样做方法没有返回值且不能抛出异常</p>
<p>Java提供了Callable接口来解决这样的问题，接口内有一个call()方法可以作为线程执行体，call()方法有返回值且可以抛出异常。</p>
<p>(1)定义</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ljqkkirito16.top">KKirito</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ljqkkirito16.top/2023/08/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://ljqkkirito16.top/2023/08/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ljqkkirito16.top" target="_blank">仰望星空时</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Markdown/">Markdown</a><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/64e18125661c6c8e54c33269.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/13/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" title="前端学习笔记（部分）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端学习笔记（部分）</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="操作系统期末复习总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统期末复习总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/05/Ant%20Design%20Vue%20%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%EF%BC%8B%E5%A4%9A%E9%80%89%E6%A1%86%E5%BC%95%E5%8F%91%E7%9A%84%E8%BE%93%E5%85%A5%E5%80%BC%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/" title="Ant Design Vue 解决表单验证＋多选框引发的输入值不生效问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="title">Ant Design Vue 解决表单验证＋多选框引发的输入值不生效问题</div></div></a></div><div><a href="/2025/03/13/JS%E5%AE%9E%E7%8E%B0%E4%BB%BF%E4%BA%AC%E4%B8%9C%E9%A6%96%E9%A1%B5%E5%95%86%E5%93%81%E8%BD%AE%E6%92%AD%E5%9B%BE/" title="JS实现仿京东首页商品轮播图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-13</div><div class="title">JS实现仿京东首页商品轮播图</div></div></a></div><div><a href="/2025/03/13/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="V8垃圾回收机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-13</div><div class="title">V8垃圾回收机制</div></div></a></div><div><a href="/2024/08/06/Vue2.7.14%E4%B8%8B%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Vue2.7.14下的单元测试环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="title">Vue2.7.14下的单元测试环境搭建</div></div></a></div><div><a href="/2023/11/15/vue%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" title="vue中的Diff算法的理解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">vue中的Diff算法的理解</div></div></a></div><div><a href="/2025/03/13/JS%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E7%90%86%E8%A7%A3/" title="JS基于原型的继承理解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-13</div><div class="title">JS基于原型的继承理解</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64e18125661c6c8e54c33269.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KKirito</div><div class="author-info__description">无论暴风将我带到什么岸边，我都将以主人的身份上岸</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kkirito16"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kkirito16" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2021090917010@std.uestc.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/qq.jpg" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/wechat.jpg" target="_blank" title="微信"><i class="fa-brands fa-weixin"></i></a><a class="social-icon" href="https://space.bilibili.com/171235920" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">更新了文章、背景图加载、评论系统。<br>追星的少年不会停下，只为寻得心中的那颗星，璀璨入心。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Java学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">一、基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9D%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">二、注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.单行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.多行注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">三、基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.浮点数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.布尔类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">四、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.声明变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.变量的类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.变量的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.转义字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">1.算术运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">2.赋值运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">3.关系运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">4.位运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">五、程序的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.顺序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.if语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-if-else%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2.if-else语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3.三目运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-if-else-if-else%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4.if-else if-else语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5.switch语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1.while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">2.do-while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">3.for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">4.循环中断</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-break%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.3.4.1.</span> <span class="toc-text">1.break语句</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-continue%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.3.4.2.</span> <span class="toc-text">2.continue语句</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">六、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.数组的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1.静态初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2.动态初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.数组的常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.访问数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.数组元素的存取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3.数组遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">4.数组最大值和最小值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">5.数组排序——冒泡排序法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%94%AF%E9%BD%BF%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.锯齿数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">七、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.方法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.方法的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.方法的递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">八、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.面向对象的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2.继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">3.多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1.类的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2.对象的创建与使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">3.类的封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">4.访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%85%AC%E6%9C%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6%EF%BC%88public%EF%BC%89"><span class="toc-number">1.8.2.4.1.</span> <span class="toc-text">1.公有访问控制符（public）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%A7%81%E6%9C%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6-private"><span class="toc-number">1.8.2.4.2.</span> <span class="toc-text">2.私有访问控制符(private)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E4%BF%9D%E6%8A%A4%E9%98%B2%E6%8A%A4%E6%8E%A7%E5%88%B6%E7%AC%A6-protected"><span class="toc-number">1.8.2.4.3.</span> <span class="toc-text">3.保护防护控制符(protected)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6%EF%BC%88defaulted"><span class="toc-number">1.8.2.4.4.</span> <span class="toc-text">4.默认访问控制符（defaulted)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">5.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.2.5.1.</span> <span class="toc-text">1.构造方法的定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.2.5.2.</span> <span class="toc-text">2.构造方法的重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8this%E8%B0%83%E7%94%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1.使用this调用类中的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8this%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.使用this调用成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8this%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3.使用this调用构造方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1.静态变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2.静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3.代码块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.5.</span> <span class="toc-text">5.内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">1.成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">2.静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">3.方法内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.5.4.</span> <span class="toc-text">4.匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.6.</span> <span class="toc-text">6.类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%A8%E6%B3%95"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">1.用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">2.重写父类方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">3.super关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.6.4.</span> <span class="toc-text">4.final关键字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.7.</span> <span class="toc-text">7.抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">1.抽象类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">2.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.7.2.1.</span> <span class="toc-text">1.接口的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.7.2.2.</span> <span class="toc-text">2.接口的继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Object%E7%B1%BB"><span class="toc-number">1.8.9.</span> <span class="toc-text">9.Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-toString-%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.9.1.</span> <span class="toc-text">1.toString()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-equals-%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.9.2.</span> <span class="toc-text">2.equals()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.10.</span> <span class="toc-text">10.工厂设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.10.1.</span> <span class="toc-text">1.简单工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.10.2.</span> <span class="toc-text">2.工厂方法模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.10.3.</span> <span class="toc-text">3.抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%8C%85"><span class="toc-number">1.8.11.</span> <span class="toc-text">11.包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.11.1.</span> <span class="toc-text">1.包的定义与使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-import%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.8.11.2.</span> <span class="toc-text">2.import语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BB%99Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85"><span class="toc-number">1.8.11.3.</span> <span class="toc-text">3.给Java应用程序打包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.8.12.</span> <span class="toc-text">12.Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.</span> <span class="toc-text">九.异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.异常的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8try-catch%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">1.使用try-catch处理异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8throws%E5%85%B3%E9%94%AE%E5%AD%97%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">2.使用throws关键字抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8throw%E5%85%B3%E9%94%AE%E5%AD%97%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">3.使用throw关键字抛出异常</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.3.</span> <span class="toc-text">4.自定义异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%AD%E8%A8%80"><span class="toc-number">1.9.4.</span> <span class="toc-text">5.断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">十.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">1.继承Thread类创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">2.实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8Callable%E6%8E%A5%E5%8F%A3%E5%92%8CFutrue%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">3.使用Callable接口和Futrue接口创建线程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/13/JS%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E7%90%86%E8%A7%A3/" title="JS基于原型的继承理解">JS基于原型的继承理解</a><time datetime="2025-03-13T12:59:20.000Z" title="发表于 2025-03-13 20:59:20">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/13/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="V8垃圾回收机制">V8垃圾回收机制</a><time datetime="2025-03-13T12:30:22.000Z" title="发表于 2025-03-13 20:30:22">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/13/%E5%89%8D%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="前端响应式的实现">前端响应式的实现</a><time datetime="2025-03-13T12:26:16.000Z" title="发表于 2025-03-13 20:26:16">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/13/JS%E5%AE%9E%E7%8E%B0%E4%BB%BF%E4%BA%AC%E4%B8%9C%E9%A6%96%E9%A1%B5%E5%95%86%E5%93%81%E8%BD%AE%E6%92%AD%E5%9B%BE/" title="JS实现仿京东首页商品轮播图">JS实现仿京东首页商品轮播图</a><time datetime="2025-03-13T12:10:20.000Z" title="发表于 2025-03-13 20:10:20">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/06/Vue2.7.14%E4%B8%8B%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Vue2.7.14下的单元测试环境搭建">Vue2.7.14下的单元测试环境搭建</a><time datetime="2024-08-06T06:25:44.000Z" title="发表于 2024-08-06 14:25:44">2024-08-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By KKirito</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://ljqkkirito16.zeabur.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://ljqkkirito16.zeabur.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>