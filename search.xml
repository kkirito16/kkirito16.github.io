<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ant Design Vue 解决表单验证＋多选框引发的输入值不生效问题</title>
    <url>/2024/08/05/Ant%20Design%20Vue%20%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%EF%BC%8B%E5%A4%9A%E9%80%89%E6%A1%86%E5%BC%95%E5%8F%91%E7%9A%84%E8%BE%93%E5%85%A5%E5%80%BC%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Ant-Design-Vue-解决表单验证＋多选框引发的输入值不生效问题"><a href="#Ant-Design-Vue-解决表单验证＋多选框引发的输入值不生效问题" class="headerlink" title="Ant Design Vue 解决表单验证＋多选框引发的输入值不生效问题"></a>Ant Design Vue 解决表单验证＋多选框引发的输入值不生效问题</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><blockquote>
<p>Vue 2</p>
<p>Ant-Design-Vue 1.7.1</p>
</blockquote>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>一个弹框组件采用了Ant Design Vue，包含一个多选框和一个输入框，整体格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a-form-model</span><br><span class="line"> ref=&quot;ruleForm&quot;</span><br><span class="line"> :model=&quot;form&quot;</span><br><span class="line"> :rules=&quot;rules&quot;</span><br><span class="line"> :label-col=&quot;labelCol&quot;</span><br><span class="line"> :wrapper-col=&quot;wrapperCol&quot;</span><br><span class="line">&gt;</span><br><span class="line">	&lt;a-form-model-item prop=&quot;nation&quot;&gt;</span><br><span class="line">     	&lt;a-select</span><br><span class="line">               mode=&quot;multiple&quot;</span><br><span class="line">               v-model=&quot;nation&quot;</span><br><span class="line">               :options=&quot;regionOptions&quot;</span><br><span class="line">               @change=&quot;onNationChange&quot;</span><br><span class="line">               style=&quot;width:600px;&quot;&gt;</span><br><span class="line">     	&lt;/a-select&gt;</span><br><span class="line">    &lt;/a-form-model-item&gt;</span><br><span class="line">    &lt;a-form-model-item prop=&quot;bidFloor&quot;&gt;</span><br><span class="line">        &lt;a-input v-model=&quot;form.bidFloor&quot; type=&quot;number&quot; style=&quot;width:600px;&quot;/&gt;</span><br><span class="line">    &lt;/a-form-model-item&gt;</span><br><span class="line">&lt;/a-form-model&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">	country: [&#123; required: true, message: this.$t(&#x27;mintAdNetwork.nationRegionErrorMessage&#x27;), trigger: &#x27;change&#x27;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出现问题</strong>：当选择国家时，不管是否有选项都提示<code>nation is required</code>  而取消掉验证规则的<code>required: true</code>发现发送的接口信息里<code>nation</code>是有值的</p>
<p>可能会有疑问：这里为什么不用<code>form.nation</code>：因为<code>Ant Design Vue</code> 的多选框<code>v-model</code>必须绑定一级字段，否则出现无法特定情况下无法点击选项的<code>bug </code>所以这里采用了<code>nation</code>这个中间值并且在<code>onNationChange</code>方法里对<code>form.country</code>进行赋值</p>
<p>但矛盾的是，<code>prop</code>的<code>nation</code>又是在<code>form</code>里找的</p>
<p>所以问题发现了：在<code>prop</code>的<code>nation</code>中找不到<code>form</code></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>将<code>prop=&quot;nation&quot;</code>改成<code>prop=&quot;country&quot;</code> 直接跳过中间值验证即可，注意规则里也应该对应修改</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a-form-model</span><br><span class="line"> ref=&quot;ruleForm&quot;</span><br><span class="line"> :model=&quot;form&quot;</span><br><span class="line"> :rules=&quot;rules&quot;</span><br><span class="line"> :label-col=&quot;labelCol&quot;</span><br><span class="line"> :wrapper-col=&quot;wrapperCol&quot;</span><br><span class="line">&gt;</span><br><span class="line">	&lt;a-form-model-item prop=&quot;country&quot;&gt;</span><br><span class="line">     	&lt;a-select</span><br><span class="line">               mode=&quot;multiple&quot;</span><br><span class="line">               v-model=&quot;nation&quot;</span><br><span class="line">               :options=&quot;regionOptions&quot;</span><br><span class="line">               @change=&quot;onNationChange&quot;</span><br><span class="line">               style=&quot;width:600px;&quot;&gt;</span><br><span class="line">     	&lt;/a-select&gt;</span><br><span class="line">    &lt;/a-form-model-item&gt;</span><br><span class="line">    &lt;a-form-model-item prop=&quot;bidFloor&quot;&gt;</span><br><span class="line">        &lt;a-input v-model=&quot;form.bidFloor&quot; type=&quot;number&quot; style=&quot;width:600px;&quot;/&gt;</span><br><span class="line">    &lt;/a-form-model-item&gt;</span><br><span class="line">&lt;/a-form-model&gt;</span><br></pre></td></tr></table></figure>

<p>解决问题!!</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现仿京东首页商品轮播图</title>
    <url>/2025/03/13/JS%E5%AE%9E%E7%8E%B0%E4%BB%BF%E4%BA%AC%E4%B8%9C%E9%A6%96%E9%A1%B5%E5%95%86%E5%93%81%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="JS实现仿京东首页商品轮播图"><a href="#JS实现仿京东首页商品轮播图" class="headerlink" title="JS实现仿京东首页商品轮播图"></a>JS实现仿京东首页商品轮播图</h1><p>近期做了一个面试题，仿照京东首页商品轮播图实现一个轮播图</p>
<h3 id="1-HTML-结构搭建"><a href="#1-HTML-结构搭建" class="headerlink" title="1. HTML 结构搭建"></a>1. HTML 结构搭建</h3><p>HTML 部分主要负责构建轮播图的整体结构，包含一个轮播图容器、图片展示区域以及分页器容器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-images&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多个图片项 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 更多图片... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.carousel</code>：作为轮播图的整体容器，用于包裹图片展示区域和分页器。</li>
<li><code>.carousel-images</code>：用于存放所有轮播图片的容器。</li>
<li><code>.carousel-image</code>：每个图片项的容器，初始状态下只有带有 <code>active</code> 类的图片项会显示。</li>
<li><code>.pagination</code>：分页器容器，后续会通过 JavaScript 动态创建分页点。</li>
</ul>
<h3 id="2-CSS-样式设计"><a href="#2-CSS-样式设计" class="headerlink" title="2. CSS 样式设计"></a>2. CSS 样式设计</h3><p>CSS 部分为轮播图添加样式，实现布局和渐隐渐显效果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.carousel</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">522px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.carousel-image</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: opacity <span class="number">1s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.carousel-image</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.carousel</code>：设置相对定位，方便内部元素进行绝对定位，同时设置宽度、边距、圆角、阴影和溢出隐藏等样式。</li>
<li><code>.carousel-image</code>：设置绝对定位，使其重叠显示，初始透明度为 0，通过 <code>transition</code> 属性实现渐隐渐显效果。</li>
<li><code>.carousel-image.active</code>：当图片项带有 <code>active</code> 类时，透明度为 1，即显示该图片。</li>
</ul>
<h3 id="3-JavaScript-功能实现"><a href="#3-JavaScript-功能实现" class="headerlink" title="3. JavaScript 功能实现"></a>3. JavaScript 功能实现</h3><h4 id="3-1-变量初始化"><a href="#3-1-变量初始化" class="headerlink" title="3.1 变量初始化"></a>3.1 变量初始化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.carousel-image&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pagination = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.pagination&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> timer;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>images</code>：获取所有的图片项元素。</li>
<li><code>pagination</code>：获取分页器容器元素。</li>
<li><code>currentIndex</code>：记录当前显示图片的索引，初始值为 0。</li>
<li><code>timer</code>：用于存储自动播放的定时器 ID。</li>
</ul>
<h4 id="3-2-分页器创建"><a href="#3-2-分页器创建" class="headerlink" title="3.2 分页器创建"></a>3.2 分页器创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">images.<span class="title function_">forEach</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">    dot.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;dot&#x27;</span>);</span><br><span class="line">    dot.<span class="property">dataset</span>.<span class="property">index</span> = index;</span><br><span class="line">    dot.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        currentIndex = index;</span><br><span class="line">        <span class="title function_">updateCarousel</span>();</span><br><span class="line">        <span class="title function_">startAutoPlay</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    pagination.<span class="title function_">appendChild</span>(dot);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历所有图片项，为每个图片项创建一个分页点（<code>&lt;span&gt;</code> 元素），并添加 <code>dot</code> 类。</li>
<li>为每个分页点设置 <code>data-index</code> 属性，用于记录其对应的图片索引。</li>
<li>为每个分页点添加点击事件监听器，点击时清除当前定时器，更新 <code>currentIndex</code> 为点击的分页点对应的索引，调用 <code>updateCarousel()</code> 函数切换图片，然后重新启动定时器。</li>
</ul>
<h4 id="3-3-图片切换函数"><a href="#3-3-图片切换函数" class="headerlink" title="3.3 图片切换函数"></a>3.3 图片切换函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateCarousel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    images.<span class="title function_">forEach</span>(<span class="function">(<span class="params">image, index</span>) =&gt;</span> &#123;</span><br><span class="line">        image.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index === currentIndex) &#123;</span><br><span class="line">            image.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.dot&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">dot</span> =&gt;</span> dot.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>));</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.dot&#x27;</span>)[currentIndex].<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历所有图片项，移除所有图片项的 <code>active</code> 类，然后为当前索引对应的图片项添加 <code>active</code> 类，实现图片的切换。</li>
<li>同样，遍历所有分页点，移除所有分页点的 <code>active</code> 类，然后为当前索引对应的分页点添加 <code>active</code> 类，更新分页器状态。</li>
</ul>
<h4 id="3-4-自动播放函数"><a href="#3-4-自动播放函数" class="headerlink" title="3.4 自动播放函数"></a>3.4 自动播放函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">startAutoPlay</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        currentIndex = (currentIndex + <span class="number">1</span>) % images.<span class="property">length</span>;</span><br><span class="line">        <span class="title function_">updateCarousel</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>setInterval</code> 函数创建一个定时器，每隔 1 秒执行一次回调函数。</li>
<li>在回调函数中，更新 <code>currentIndex</code> 为下一张图片的索引（使用取模运算符确保索引不会越界），然后调用 <code>updateCarousel()</code> 函数切换图片。</li>
</ul>
<h4 id="3-5-初始化操作"><a href="#3-5-初始化操作" class="headerlink" title="3.5 初始化操作"></a>3.5 初始化操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updateCarousel</span>();</span><br><span class="line"><span class="title function_">startAutoPlay</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>updateCarousel()</code> 函数进行初始化，显示第一张图片并更新分页器状态。</li>
<li>调用 <code>startAutoPlay()</code> 函数启动自动播放功能。</li>
</ul>
<p>综上所述，通过 HTML 构建结构、CSS 设置样式和 JavaScript 实现交互逻辑，完成了一个具有渐隐渐显效果、支持自动播放和手动切换的轮播图。</p>
<h3 id="4-全部代码"><a href="#4-全部代码" class="headerlink" title="4.全部代码"></a>4.全部代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>水平轮播图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">522px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">750px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.carousel</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto; </span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 设置一个合适的高度，可根据实际图片比例调整 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">750px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">522px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.carousel-images</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.carousel-image</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition</span>: opacity <span class="number">1s</span> ease;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.carousel-image</span><span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.carousel</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">object-fit</span>: cover;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.pagination</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dot</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#bbb</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.dot</span><span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#717171</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-images&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image 6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> images = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.carousel-image&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> pagination = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.pagination&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> timer;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建分页器</span></span></span><br><span class="line"><span class="language-javascript">        images.<span class="title function_">forEach</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> dot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            dot.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;dot&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            dot.<span class="property">dataset</span>.<span class="property">index</span> = index;</span></span><br><span class="line"><span class="language-javascript">            dot.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 清除当前定时器</span></span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="language-javascript">                currentIndex = index;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">updateCarousel</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 重新启动定时器</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">startAutoPlay</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            pagination.<span class="title function_">appendChild</span>(dot);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">updateCarousel</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            images.<span class="title function_">forEach</span>(<span class="function">(<span class="params">image, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                image.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (index === currentIndex) &#123;</span></span><br><span class="line"><span class="language-javascript">                    image.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 更新分页器状态</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.dot&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">dot</span> =&gt;</span> dot.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.dot&#x27;</span>)[currentIndex].<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">startAutoPlay</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                currentIndex = (currentIndex + <span class="number">1</span>) % images.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">updateCarousel</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">updateCarousel</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 启动自动播放</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">startAutoPlay</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/15/JS%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="JS异步"><a href="#JS异步" class="headerlink" title="JS异步"></a>JS异步</h1><h2 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h2><p>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p>
<p>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是在ES6中确定的对异步及回调处理的规范实现。</p>
<p>一个 Promise 必然处于以下几种状态之一：</p>
<ul>
<li>待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</li>
<li>已兑现（fulfilled）: 意味着操作成功完成。</li>
<li>已拒绝（rejected）: 意味着操作失败。</li>
</ul>
<p>使用Promise封装ajax</p>
<p>关键：<code>return new Promise((resolve, reject)=&gt;&#123;...&#125;)</code> 用以返回一个Promise对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax = <span class="function">(<span class="params">method, url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123; <span class="comment">//关键，用以返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() </span><br><span class="line">        request.<span class="title function_">open</span>(method, url)</span><br><span class="line">        request.<span class="property">onreadystateChange</span> = <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">            <span class="keyword">if</span>(request.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="params">                <span class="variable language_">console</span>.log(<span class="string">&#x27;请求完成&#x27;</span>)</span></span><br><span class="line"><span class="params">                <span class="keyword">if</span>(request.responese.status === <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="params">                    <span class="variable language_">console</span>.log(<span class="string">&#x27;请求成功&#x27;</span>)</span></span><br><span class="line"><span class="params">                    resolve.call(<span class="literal">null</span>, request.response) //成功则调用resolve</span></span><br><span class="line"><span class="params">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="params">                    <span class="variable language_">console</span>.log(<span class="string">&#x27;请求失败&#x27;</span>)</span></span><br><span class="line"><span class="params">                    reject.call(<span class="literal">null</span>, request) //失败则调用reject</span></span><br><span class="line"><span class="params">                &#125;</span></span><br><span class="line"><span class="params">            &#125;</span></span><br><span class="line"><span class="params">        </span>)</span><br><span class="line">        request.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个Promise对象具有then函数，then函数接受两个函数，第一个函数当 Promise 变成接受状态（fulfilled）时被调用，第二个函数当 Promise 变成拒绝状态（rejected）时被调用。</p>
<p>catch 接收一个函数，在Promise被reject的时候执行，除非该函数抛出错误或返回一个失败的Promise，否则返回的Promise一直是resolved。实质上catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。</p>
<p>finally接收一个回调函数，在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定该回调函数。这避免了同样的语句需要在then()和catch()中各写一次的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res),</span><br><span class="line">    <span class="function"><span class="params">request</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(request)</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">.<span class="title function_">finally</span>( <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>) )</span><br></pre></td></tr></table></figure>

<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async和await都是JavaScript中用于处理异步操作的关键字。</p>
<p>async关键字用于声明一个函数是异步函数。异步函数在执行过程中可以暂停，并且可以在某些操作完成之后恢复执行。它们返回一个Promise对象，可以通过await关键字来等待该Promise对象的解决（即完成）。</p>
<p>而await关键字只能在异步函数内部使用。它可以放在一个返回Promise对象的表达式前面，暂停异步函数的执行，直到该Promise对象解决为止。在等待期间，JavaScript引擎可以继续执行其他任务，以避免阻塞线程。一旦Promise对象解决，await表达式会返回解决的值，并且异步函数会继续执行。</p>
<p>以下是async和await的简单用法：</p>
<p>async function fetchData() { try {  const response &#x3D; await fetch(‘<a href="https://api.example.com/data">https://api.example.com/data</a>‘);  const data &#x3D; await response.json();  console.log(data); } catch (error) {  console.log(‘Error:’, error); }}fetchData();</p>
]]></content>
  </entry>
  <entry>
    <title>V8垃圾回收机制</title>
    <url>/2025/03/13/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h1><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>目标：清除不再使用的对象，使腾退出所占用的内存</p>
<p>在浏览器的发展历史上有两种解决策略：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除分为：标记阶段和清除阶段。</p>
<p>首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。</p>
<p>使用标记清除策略的最重要的优点在于简单，无非是标记和不标记的差异。通过标记清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，这就造成出现内存碎片的问题。内存碎片多了后，如果要存储一个新的需要占据较大内存空间的对象，就会造成影响。对于通过标记清除产生的内存碎片，还是需要通过标记整理策略进行解决。</p>
<p>简而言之：</p>
<ul>
<li>优点：简单</li>
<li>缺点：内存碎片化、分配速度慢</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>经过标记清除策略整理后，老生代内存中因此产生了许多内存碎片，如果不进行清理内存碎片，就会对存储造成影响。</p>
<p><strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决标记清除的两个缺点。它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数是一种不常见的垃圾回收策略，其思路就是对每个值都记录其的引用次数。具体的：</p>
<ul>
<li>当变量进行声明并赋值后，值的引用数为1。</li>
<li>当同一个值被赋值给另一个变量时，引用数+1</li>
<li>当保存该值引用的变量被其它值覆盖时，引用数-1</li>
<li>当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。</li>
</ul>
<p>这种回收策略看起来很方便，<strong>但是当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。</strong>当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。</p>
<h2 id="V8对于垃圾回收机制的优化"><a href="#V8对于垃圾回收机制的优化" class="headerlink" title="V8对于垃圾回收机制的优化"></a>V8对于垃圾回收机制的优化</h2><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。</p>
<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。</p>
<p>V8 整个堆内存的大小就等于新生代加上老生代的内存，对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20231109155126666.png" alt="image-20231109155126666"></p>
<p>新生代内存回收的原理是：</p>
<ul>
<li>新加入的对象都会存放在使用区，当使用区快写满时就进行一次垃圾清理操作。</li>
<li>在开始进行垃圾回收时，新生代回收器会对使用区内的对象进行标记</li>
<li>标记完成后，需要对使用区内的活动对象拷贝到空闲区进行排序</li>
<li>而后进入垃圾清理阶段，将非活动对象占用的内存空间进行清理</li>
<li>最后对使用区和空闲区进行交换，使用区-&gt;空闲区，空闲区-&gt;使用区</li>
</ul>
<p>老生代内存回收的原理是：使用Mark-Sweep（标记清除）和Mark-Compact（标记整理）的策略</p>
<p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。</p>
<p>同样的标记清除策略会产生内存碎片，因此还需要进行标记整理策略进行优化。</p>
<p>另外，因为JS是单线程语言，所以在执行垃圾回收机制的时候，JS执行会被暂停，称为全停顿。而V8机制对这种情况做了一定的优化，垃圾回收机制支持多线程并行回收，提高了垃圾回收的效率。但是仍然会阻塞JS的执行，所以就诞生了增量标记。增量标记可以使得垃圾回收可以分段执行，最大化保证了JS的执行。V8机制还支持了并发回收。JS在主线程执行，垃圾回收在辅助线程执行</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2023/08/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Java学习笔记"><a href="#Java学习笔记" class="headerlink" title="Java学习笔记"></a>Java学习笔记</h2><h3 id="一、基本格式"><a href="#一、基本格式" class="headerlink" title="一、基本格式"></a>一、基本格式</h3><h4 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h4><p>类是Java的基本结构，一个程序可以包含一个或多个类</p>
<p>类的申明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修饰符class类名&#123;</span></span><br><span class="line"><span class="comment">	 程序代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;            <span class="comment">//声明一个名为HelloWorld的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2.修饰符"></a>2.修饰符</h4><p>修饰符用于指定数据、方法、类的属性以及用法</p>
<p>修饰符示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;                  <span class="comment">//public修饰为公有的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;     <span class="comment">//static修饰为静态的</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-块"><a href="#3-块" class="headerlink" title="3.块"></a>3.块</h4><p>Java中使用左大括号({)和右大括号(})将语句编组，组中的语句称为代码块或块语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xxxx</span></span><br></pre></td></tr></table></figure>

<h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   xxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注：多行注释中可以嵌套单行注释，但多行注释中不能嵌套多行注释</p>
<h3 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h3><h4 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h4><p>在Java中，整数类型分为字节型（byte）、短整型（short）、整型（int）和长整型（long）四种</p>
<p>在Java中直接给出一个整数值，其默认类型就是int类型。使用中通常有两种情况：</p>
<p>（1）直接将一个在byte在short类型取值范围内的整数值赋给byte或short变量，系统会自动把这个整数当成byte或short类型来处理。</p>
<p>（2）将一个超出int取值范围内的整数值赋给long变量，系统不会自动把这个整数值当成long类型来处理。此时必须声明long类型常量，即在整数值后面添加字母l或L。如果数值未超过int型的取值范围，则可以省略字母l和L。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">99999</span>;          <span class="comment">//所赋的值未超出int取值范围，可以加L，也可省略</span></span><br><span class="line"><span class="type">long</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">9999999999L</span>;      <span class="comment">//所赋的值超出int取值范围，必须加L后缀</span></span><br></pre></td></tr></table></figure>

<h4 id="2-浮点数类型"><a href="#2-浮点数类型" class="headerlink" title="2.浮点数类型"></a>2.浮点数类型</h4><p>在Java中，浮点数分为两种：单精度浮点数（float）和双精度浮点数（double）。</p>
<p>在Java中，使用浮点数数值时，默认的类型是double，在数值后面可加上d或D，作为double类型的标识。在数值后面加上f或F，则作为float类型的识别。若没有加上，Java就会将该数据视为double类型，而在编译时就会发生错误，提示可能会丢失精度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10.0</span>;    <span class="comment">//数值默认为double型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10.0</span>;     <span class="comment">//将丢失精度，错误赋值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span><span class="number">10.0f</span>;     <span class="comment">//正确赋值，给数值添加f后缀，将数值视为float型</span></span><br></pre></td></tr></table></figure>

<h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h4><p>字符型变量用了存储单个字符，字符型值必须使用英文半角格式的单引号”‘“括起来。Java采用char表示字符型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;    <span class="comment">//为一个char类型的变量赋值字符b</span></span><br></pre></td></tr></table></figure>

<h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h4><p>布尔类型的值只有true(真)和false（假）两种,Java的布尔类型用boolean表示，占用1B内存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//声明boolean型变量值为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">//声明boolean型变量值为false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">//不能用非0来代表真，错误</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//不能用0来代表假，错误</span></span><br></pre></td></tr></table></figure>

<h3 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h3><h4 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1.声明变量"></a>1.声明变量</h4><p>声明格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名;</span><br><span class="line">数据类型 变量名<span class="number">1</span>，变量名<span class="number">2</span>,......,变量名n;</span><br></pre></td></tr></table></figure>

<h4 id="2-变量的类型转换"><a href="#2-变量的类型转换" class="headerlink" title="2.变量的类型转换"></a>2.变量的类型转换</h4><p>隐式转换（自动类型转换）：取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再运算。byte、short、char三种类型的数据在运算的时候，都会直接提升为int，然后再进行运算</p>
<p>强制转换：如果把一个取值范围大的数值，赋值给取值范围小的变量，是不允许直接赋值的。如果一定要这么做，就需要加入强制转换。</p>
<p>格式：目标数据类型 变量名 &#x3D; （目标数据类型）被强转的数据</p>
<p>注：强制转换可能出现错误</p>
<h4 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h4><p>变量声明在程序中的位置决定了变量的作用域。变量一定会声明在一对大括号中，该大括号所包含的代码区域就是这个变量的作用域。</p>
<h4 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h4><p>常量是不能被改变的数据。Java程序中使用的直接量称为常量，是在程序中通过源代码直接给出的值，在整个程序执行过程中都不会改变，也称最终量。</p>
<h4 id="5-转义字符"><a href="#5-转义字符" class="headerlink" title="5.转义字符"></a>5.转义字符</h4><ol>
<li>\b,退格键，Unicode码为\u0008</li>
<li>\t,Tab键，Unicode码为\u0009</li>
<li>\n,换行符,Unicode码为\u000A</li>
<li>\r，回车符，Unicode码为\u000D</li>
</ol>
<h4 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h4><h5 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h5><h5 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h5><h5 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3.关系运算符"></a>3.关系运算符</h5><p>&amp;、&amp;&amp;运算符的区别：</p>
<p>都表示与操作，运算符前后的两个操作数皆为true，运算的结果才会为true，否则为flase。两者在使用上有一定的区别：使用&amp;运算符，要求对运算符前后两个操作数都进行判断；而使用&amp;&amp;运算符，当运算符前面的操作数的值为false时，则其后面的操作数将不再判断。</p>
<p>|与||的区别同上。</p>
<h5 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4.位运算符"></a>4.位运算符</h5><p>‘&lt;&lt;’  左移 eg.0000 0001&lt;&lt;2 结果：0000 0100</p>
<p>‘&gt;&gt;’  右移 eg.1000 0100&gt;&gt;2 结果：1110 0001</p>
<p>左移后右边空位补0，左边移出的舍弃；右移同理可得。</p>
<p>‘&gt;&gt;&gt;’ 无符号右移运算符，将操作数的二进制位整体右移指定位数，右移后左边空位补0，右边移出去的舍弃。</p>
<p>进行位移运算遵循如下规则：</p>
<p>（1）对于低于int类型（byte、short和char）的操作数总是先自动转换为int类型后再位移。</p>
<p>（2）对于int类型的位移，当位移数大于int位数32时，Java先用位移数对32求余，得到的余数才是真正的位移数。</p>
<p>（3）对于long类型的位移，当位移数大于long位数64时，Java先用位移数对64求余，得到的余数才是真正的位移数。</p>
<p>但低于int类型的操作数进行无符号位移时，需注意，如果操作数是负数，在自动转换过程中会发生截断，数据丢失，导致位移结果不正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBitOperation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>-<span class="number">12</span>&gt;&gt;&gt;<span class="number">3</span>;   <span class="comment">//对int型无符号右移3位</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">m</span> <span class="operator">=</span>(<span class="type">byte</span>)(a&gt;&gt;&gt;b);   <span class="comment">//对byte类型无符号右移3位</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、程序的结构"><a href="#五、程序的结构" class="headerlink" title="五、程序的结构"></a>五、程序的结构</h3><p>一般来说，程序的结构分为顺序结构、选择结构和循环结构三种，它们都有一个共同的特点是都只有一个入口，也只有一个出口。</p>
<h4 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h4><h4 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h4><p>Java提供了两种分支结构语句：if语句和switch语句。其中，if语句使用布尔表达式或布尔值作为分支条件来进行分支控制；而switch语句用于对多个整数值进行匹配，从而实现多分支控制。</p>
<h5 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            perimeter =<span class="number">2</span>*r*PI;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆半径&quot;</span>+r+<span class="string">&quot;的周长为：&quot;</span>+perimeter);</span><br><span class="line">        r=<span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            area=r*r*PI;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆半径&quot;</span>+r+<span class="string">&quot;的面积为：&quot;</span>+area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-if-else语句"><a href="#2-if-else语句" class="headerlink" title="2.if-else语句"></a>2.if-else语句</h5><h5 id="3-三目运算符"><a href="#3-三目运算符" class="headerlink" title="3.三目运算符"></a>3.三目运算符</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">判断条件？表达式<span class="number">1</span>：表达式<span class="number">2</span>；</span><br></pre></td></tr></table></figure>

<p>当判断条件成立时，执行表达式1，否则将执行表达式2.</p>
<h5 id="4-if-else-if-else语句"><a href="#4-if-else-if-else语句" class="headerlink" title="4.if-else if-else语句"></a>4.if-else if-else语句</h5><p>由于if语句体或else语句体可以是多条语句，所以如果需要在if-else里判断多个条件，可以“随意”嵌套。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式n)&#123;</span><br><span class="line">    语句块n</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句块n+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5.switch语句"></a>5.switch语句</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">     <span class="keyword">default</span> :</span><br><span class="line">        默认语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用switch语句需注意：</p>
<ol>
<li>switch语句的判定条件只能是byte、short、char和int四种基本类型，JDK5.0开始支持枚举类型，JDK7.0开始支持String类型，不能是boolean类型。</li>
<li>常量1~常量N必须与判断条件类型相同，且为常量表达式，不能是变量。</li>
<li>case字句后面可以有多条语句，这些语句可以使用大括号括起来。</li>
<li>程序将从第一个匹配的case字句处开始执行后面的所有代码（包括后面case字句中的代码）。可以使用break跳出switch语句。</li>
<li>default语句是可选的，当所有case字句条件都不满足时执行。</li>
</ol>
<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h4><p>Java程序设计中引入了循环语句。循环语句共有三种常见的形式：while循环语句、do-while循环语句和for循环语句</p>
<h5 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1.while循环"></a>1.while循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>循环语句也是条件判断语句，用于事先不知道循环次数的情况，其语法格式如下：</span><br><span class="line">    <span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">        循环体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-do-while循环"><a href="#2-do-while循环" class="headerlink" title="2.do-while循环"></a>2.do-while循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure>

<p>do-while语句与while语句还有一个明显的区别是，如果while语句误添加分号，会导致死循环，而do-while的循环条件后面必须有一个分号，用来表明循环结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDoWhile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;1~100的累加和：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(赋初始值;循环条件;迭代语句)&#123;</span><br><span class="line">    语句i;</span><br><span class="line">...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-循环中断"><a href="#4-循环中断" class="headerlink" title="4.循环中断"></a>4.循环中断</h5><h6 id="1-break语句"><a href="#1-break语句" class="headerlink" title="1.break语句"></a>1.break语句</h6><p>注：如果break语句出现在嵌套循环中的内层循环，则break语句只会跳出当前层的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBreak</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>==i)</span><br><span class="line">                <span class="keyword">break</span>;     <span class="comment">//执行该语句将结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在有些场景下，需要从很深的循环中退出时，可以使用带标记的break语句，标记必须break所在循环的外层循环之前定义才有意义，定义在当前循环之前，就失去标记的意义，因为break默认就是结束其所在循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBreakLabel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        label:    <span class="comment">//定义标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;,&quot;</span>+j);</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> label;   <span class="comment">//跳出label标记所标识的循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-continue语句"><a href="#2-continue语句" class="headerlink" title="2.continue语句"></a>2.continue语句</h6><p>在while、do-while和for语句的循环体中，执行continue语句可以结束本次循环而立即测试循环体的条件，执行下一次循环，但不会终止整个循环</p>
<h3 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h3><p>在一个数组中，数组元素的类型是唯一的，即一个数组中只能存储同一种数据类型的数据，而不能存储多种数据类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义方式<span class="number">1</span>：</span><br><span class="line">数据类型[]数组名；</span><br><span class="line">定义方式<span class="number">2</span>：</span><br><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>

<h4 id="1-数组的初始化"><a href="#1-数组的初始化" class="headerlink" title="1.数组的初始化"></a>1.数组的初始化</h4><p>数组初始化，就是让数组名指向数组对象的过程，该过程主要分为两个步骤：一是对数组名进行初始化，即为数组中的元素分配内存空间和赋值；二是对数组名进行初始化，即将数组名赋值为数组对象的引用。</p>
<h5 id="1-静态初始化"><a href="#1-静态初始化" class="headerlink" title="1.静态初始化"></a>1.静态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：</span><br><span class="line">Int[]array;    <span class="comment">//声明一个int类型的数组</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;；    <span class="comment">//静态初始化数组</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//声明并初始化数组</span></span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line">Int[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//声明并初始化一个int类型的数组</span></span><br></pre></td></tr></table></figure>

<p>其中大括号包含数组元素值，元素值之间用逗号”,”分隔。</p>
<h5 id="2-动态初始化"><a href="#2-动态初始化" class="headerlink" title="2.动态初始化"></a>2.动态初始化</h5><p>动态初始化是指程序员在初始化数组时指定数组的长度，由系统为数组元素分配初始值。</p>
<p>数组动态初始化的具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];    <span class="comment">//动态初始化数组</span></span><br></pre></td></tr></table></figure>

<h4 id="2-数组的常用操作"><a href="#2-数组的常用操作" class="headerlink" title="2.数组的常用操作"></a>2.数组的常用操作</h4><h5 id="1-访问数组"><a href="#1-访问数组" class="headerlink" title="1.访问数组"></a>1.访问数组</h5><p>在Java中，数组对象有一个length属性，用于表示数组的长度</p>
<p>获取数组长度的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名.length</span><br></pre></td></tr></table></figure>

<p>接下来用length属性获取数组的长度，具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] list =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];      <span class="comment">//定义一个int类型的数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.length;      <span class="comment">//size = 10;数组的长度</span></span><br></pre></td></tr></table></figure>

<h5 id="2-数组元素的存取"><a href="#2-数组元素的存取" class="headerlink" title="2.数组元素的存取"></a>2.数组元素的存取</h5><p>通过操作数组的下标可以访问到数组中的元素，也可以实现数组元素的存取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//声明数组</span></span><br><span class="line">        <span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//存入数组元素</span></span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">10</span>;</span><br><span class="line">        a[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">        <span class="comment">//读取数组元素</span></span><br><span class="line">        System.out.print(<span class="string">&quot;数组的元素为：&quot;</span>);</span><br><span class="line">        System.out.println(a[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">3</span>]+<span class="string">&quot;,&quot;</span>+a[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从输出结果来看，数组的元素已经存取成功，但数组下标为2、3的位置中并未存入数据，但是却能取到数据为0的元素，可见声明为int类型的数组元素的默认值为0</span></span><br></pre></td></tr></table></figure>

<h5 id="3-数组遍历"><a href="#3-数组遍历" class="headerlink" title="3.数组遍历"></a>3.数组遍历</h5><p>for循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayTraversal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span>&#123;   </span><br><span class="line">        <span class="type">int</span>[] list=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;          <span class="comment">//定义数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.length;i++) &#123;   <span class="comment">//遍历数组元素</span></span><br><span class="line">            System.out.println(list[i]);    <span class="comment">//索引访问数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-数组最大值和最小值"><a href="#4-数组最大值和最小值" class="headerlink" title="4.数组最大值和最小值"></a>4.数组最大值和最小值</h5><h5 id="5-数组排序——冒泡排序法"><a href="#5-数组排序——冒泡排序法" class="headerlink" title="5.数组排序——冒泡排序法"></a>5.数组排序——冒泡排序法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">88</span>,<span class="number">62</span>,<span class="number">12</span>,<span class="number">100</span>,<span class="number">28</span>&#125;;</span><br><span class="line">        <span class="comment">//外层循环控制排序轮数</span></span><br><span class="line">        <span class="comment">//最后一个元素，不用再比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//内层循环控制元素两两比较的次数</span></span><br><span class="line">            <span class="comment">//每轮循环沉底一个元素，沉底元素不用再参加比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较相邻元素</span></span><br><span class="line">                <span class="keyword">if</span> (array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//交换元素</span></span><br><span class="line">                    <span class="type">int</span> tmp=array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印每轮排序结果</span></span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮排序：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                System.out.print(array[j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;最终排序： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3.二维数组"></a>3.二维数组</h4><p>二维数组的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][]array;</span><br><span class="line"><span class="type">int</span> array[][];</span><br></pre></td></tr></table></figure>

<p>二维数组的动态初始化示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];      <span class="comment">//动态初始化3×2的二维数组</span></span><br><span class="line">array[<span class="number">0</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;           <span class="comment">//初始化二维数组的第一个元素</span></span><br><span class="line">array[<span class="number">1</span>]=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;           <span class="comment">//初始化二维数组的第二个元素</span></span><br><span class="line">array[<span class="number">2</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;           <span class="comment">//初始化二维数组的第三个元素</span></span><br></pre></td></tr></table></figure>

<p>二维数组的静态初始化示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-锯齿数组"><a href="#4-锯齿数组" class="headerlink" title="4.锯齿数组"></a>4.锯齿数组</h4><p>二维数组中每一行就是一个一维数组，因此，各行的长度就可以不同，这样的数组称为锯齿数组。</p>
<h3 id="七、方法"><a href="#七、方法" class="headerlink" title="七、方法"></a>七、方法</h3><p>方法是一段可重复使用的代码，为执行一个操作组合在一起的语句集合，用于解决特定的问题。</p>
<h4 id="1-方法的定义"><a href="#1-方法的定义" class="headerlink" title="1.方法的定义"></a>1.方法的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名([参数类型 参数名<span class="number">1</span>，参数类型 参数名<span class="number">2</span>，...])&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方法需注意：</p>
<p>(1)修饰符：方法的修饰符较多，有对访问去权限进行限定的，有静态修饰符static，还有最终修饰符final等。</p>
<p>(2)返回值类型：限定返回值的类型。</p>
<p>(3)参数类型：限定调用方法时传入参数的数据类型。</p>
<p>(4)参数名：是一个变量，用于接受调用方法指定类型的值。</p>
<p>(5)return:关键字，用于结束方法以及返回方法指定类型的值。</p>
<p>(6)返回值：被return返回的值，该值返回给调用者。</p>
<p>方法头中声明的变量称为实际参数，简称实参。形参列表是指形参的类型、顺序和数量。方法不需要任何参数，则形参列表为空。</p>
<h4 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用"></a>2.方法的调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">large</span> <span class="operator">=</span> max(<span class="number">3</span>,<span class="number">4</span>);    <span class="comment">//将方法的返回值赋给变量</span></span><br><span class="line">System.out.println(max(<span class="number">3</span>,<span class="number">4</span>));   <span class="comment">//直接打印方法的返回值</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//println方法没有返回值</span></span><br></pre></td></tr></table></figure>

<p>如果方法定义中包含形参，调用时必须提供实参。实参的类型必须与形参的类型兼容，实参顺序必须与形参的顺序一致。实参的值传递给方法的形参，称为值传递，方法内部对形参的修改不影响实参值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;before main\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">        swap(n,m);</span><br><span class="line">        System.out.println(<span class="string">&quot;end main\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before swap\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">        <span class="type">int</span> tmp=n;</span><br><span class="line">        n=m;</span><br><span class="line">        m=tmp;</span><br><span class="line">        System.out.println(<span class="string">&quot;end swap\t:n=&quot;</span>+n+<span class="string">&quot;,m=&quot;</span>+m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">before main	:n=5,m=2</span></span><br><span class="line"><span class="comment">before swap	:n=5,m=2</span></span><br><span class="line"><span class="comment">end swap	:n=2,m=5</span></span><br><span class="line"><span class="comment">end main	:n=5,m=2</span></span><br><span class="line"><span class="comment">说明swap不能交换实参的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3.方法的重载"></a>3.方法的重载</h4><p>方法重载是指方法名称相同，但形参列表不同的方法。调用重载的方法时，Java编译器会根据实参列表寻找最匹配的方法进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.DoublePredicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//调用max(int,int)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3和8的最大值：&quot;</span>+max(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.0和8.0的最大值：&quot;</span>+max(<span class="number">3.0</span>,<span class="number">8.0</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.0、5.0和8.0的最大值:&quot;</span>+max(<span class="number">3.0</span>,<span class="number">5.0</span>,<span class="number">8.0</span>));</span><br><span class="line">        <span class="comment">//调用max(double,double)方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3和8.0的最大值：&quot;</span>+max(<span class="number">3</span>,<span class="number">8.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回两个整数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回两个浮点数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> result;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回三个浮点数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1,<span class="type">double</span> num2,<span class="type">double</span> num3)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(max(num1,num2),num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但值得一提的是，调用一个方法时，出现两个或多个可能的匹配时，编译器无法判断哪个是最精确的匹配，则会产生编译错误，称为歧义调用。</p>
<h4 id="4-方法的递归"><a href="#4-方法的递归" class="headerlink" title="4.方法的递归"></a>4.方法的递归</h4><p>递归用于解决使用简单循环难以实现的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4的阶乘：&quot;</span>+fact(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算阶乘</span></span><br><span class="line"><span class="comment">        阶乘计算公式：</span></span><br><span class="line"><span class="comment">        0！=1</span></span><br><span class="line"><span class="comment">        n！=n*(n-1)!;n&gt;0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n*fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h3><h4 id="1-面向对象的概念"><a href="#1-面向对象的概念" class="headerlink" title="1.面向对象的概念"></a>1.面向对象的概念</h4><p>面向对象思想是人类最自然的一种思考方式，它将所有预处理的问题抽象为对象，同时了解这些对象具有哪些相应的属性以及如何展示这些对象的行为，以解决这些对象面临的一些实际问题，这样就在程序开发中引入了面向对象设计的概念，面向对象设计实际上就是对现实世界进行建模工作。</p>
<h5 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h5><p>封装是面向对象程序设计的核心思想。它是指将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节，这就是封装的思想。</p>
<p>eg.计算机的主机是由内存条、硬盘、风扇等部件组成，生产厂家把这些部件用一个外壳封装起来组成主机，用户在使用该主机时，无须关心其内部的组成及工作原理。</p>
<h5 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h5><p>继承是面向对象程序设计提高重用性的重要措施。它体现了特殊类与一般类之间的关系，当特殊类包含一般类的所有属性和行为，并且特殊类还可以有自己的属性和行为时，称作特殊类继承了一般类。一般类又称为父类或基类，特殊类又称为子类或派生类。</p>
<p>eg.已经描述了汽车模型这个类的属性和行为，如果需要描述一个小轿车类，只需让小轿车类继承汽车模型类，然后再描述小轿车类特有的属性和行为，而不必再重复描述一些在汽车模型类中已有的属性和行为。</p>
<h5 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h5><p>多态是面向对象程序设计的重要特征。</p>
<p>eg.生活中也有很多多态，如学校的下课铃声响后，有学生去买零食、有学生去打球、有学生在聊天等等。</p>
<h4 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2.类与对象"></a>2.类与对象</h4><p>对象是事物存在的实体，如学生、汽车等。在计算机世界中，面向对象程序设计的思想要以对象来思考问题，首先要将现实世界的实体抽象为对象，然后考虑这个对象具备的属性和行为。</p>
<h5 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1.类的定义"></a>1.类的定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">    属性类型 成员变量名;   <span class="comment">//成员变量（对象属性）</span></span><br><span class="line">    ...</span><br><span class="line">    修饰符 返回值类型 方法名([参数列表])&#123;   <span class="comment">//成员方法(对象行为)</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-对象的创建与使用"><a href="#2-对象的创建与使用" class="headerlink" title="2.对象的创建与使用"></a>2.对象的创建与使用</h5><p>声明对象格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名</span><br></pre></td></tr></table></figure>

<p>初始化类，Java使用new关键字来创建对象，也称为实例化对象，其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>访问对象的成员变量和成员方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//实例化第一个Person对象</span></span><br><span class="line">        Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//实例化第二个Person对象</span></span><br><span class="line">        p1.name=<span class="string">&quot;张三&quot;</span>;           <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.age=<span class="number">18</span>;                <span class="comment">//调用对象的方法</span></span><br><span class="line">        p1.say();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意的是，一个对象能被多个变量所引用，当对象不被任何变量所引用时，该对象就会成为垃圾，不能再被使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;,年龄&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectRef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line">        p1.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        p1.age=<span class="number">18</span>;</span><br><span class="line">        p2.name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        p2.age=<span class="number">28</span>;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1.say();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment">姓名：张三,年龄18</span></span><br><span class="line"><span class="comment">姓名：张三,年龄18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p2被赋值p1后，会断开原有引用的对象，而和p1引用同一对象。因此打印以上内容。此时，p2原有引用的对象不再被任何变量所引用，就成了垃圾对象，不能再被使用，只等待垃圾回收机制进行回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-类的封装"><a href="#3-类的封装" class="headerlink" title="3.类的封装"></a>3.类的封装</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;                  <span class="comment">//声明姓名属性</span></span><br><span class="line">    <span class="type">int</span> age;                     <span class="comment">//声明年龄属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> say&#123;                <span class="comment">//定义显示信息的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名:&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();      <span class="comment">//实例化一个Person对象</span></span><br><span class="line">        p1.name = <span class="string">&quot;张三&quot;</span>;           <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.age = -<span class="number">18</span>;              <span class="comment">//为age属性赋值</span></span><br><span class="line">        p1.say();                 <span class="comment">//调用对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免外界随意访问类中的属性，就需要用到封装，即不让使用者访问类的内部成员。Java中使用private关键字来修饰私有属性，私有属性只能在它所在的类中被访问。但这样做使所有的对象都不能访问这个类中的私有属性。为了让外部使用者访问类中的私有属性，需要提供public关键字修饰的属性访问器，即用于设置属性的setXxx()方法和获取属性的getXxx()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;       <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;          <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String str)</span>&#123;    <span class="comment">//设置属性方法</span></span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;  <span class="comment">//获取属性方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>&amp;&amp;n&lt;<span class="number">200</span>)   <span class="comment">//验证年龄，过滤掉不合理的</span></span><br><span class="line">            age = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;      <span class="comment">//定义显示信息的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;,年龄:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();      <span class="comment">//实例化一个Person对象</span></span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);            <span class="comment">//为name属性赋值</span></span><br><span class="line">        p1.setAge(-<span class="number">18</span>);                <span class="comment">//为age属性赋值</span></span><br><span class="line">        p1.say();                      <span class="comment">//调用对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4.访问修饰符"></a>4.访问修饰符</h5><p>Java中的访问修饰符是指能够控制类、成员变量、方法的使用权限的关键字。通常放在语句的最前端。类的访问修饰符只有一个public，属性和方法能够被四个修饰符修饰，分别是：public、private、protected，还有一个默认权限default。</p>
<h6 id="1-公有访问控制符（public）"><a href="#1-公有访问控制符（public）" class="headerlink" title="1.公有访问控制符（public）"></a>1.公有访问控制符（public）</h6><p>对所有类可见，被声明public的类、方法和接口允许被程序中的任何类访问。Java的类是通过包的概念来组织的。包是类的一个松散的集合，处于同一个包中的类可以不需要任何说明方便地相互访问和引用，而对于不同包中的类，则需要导入相应public类所在的包。每个java程序的主类必须是public修饰的类，否则Java解释器将不能运行该类。</p>
<h6 id="2-私有访问控制符-private"><a href="#2-私有访问控制符-private" class="headerlink" title="2.私有访问控制符(private)"></a>2.私有访问控制符(private)</h6><p>私有的，即在同一类内可见。被private修饰的属性或方法被提供了最高的保护级别，只能由该类自身访问或修改，而且不能被任何其他类(包括该类的子类)来获取或引用</p>
<h6 id="3-保护防护控制符-protected"><a href="#3-保护防护控制符-protected" class="headerlink" title="3.保护防护控制符(protected)"></a>3.保护防护控制符(protected)</h6><p>受保护的，即对同一包的类和所有子类可见，可以用来修饰属性、方法，不能修饰类。protected修饰的成员变量可以被3种类所引用：该类自身、与它在同一个包中的其他类、在其他包中该类的子类。使用protected修饰符的主要作用是允许其他包中该类的子类来访问父类的特定属性。</p>
<h6 id="4-默认访问控制符（defaulted"><a href="#4-默认访问控制符（defaulted" class="headerlink" title="4.默认访问控制符（defaulted)"></a>4.默认访问控制符（defaulted)</h6><p>默认访问控制权规定，该类只能被同一个包中的类访问和引用，而不可以被其他包中的类使用，这种访问特性又称为包访问性。</p>
<h5 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5.构造方法"></a>5.构造方法</h5><h6 id="1-构造方法的定义"><a href="#1-构造方法的定义" class="headerlink" title="1.构造方法的定义"></a>1.构造方法的定义</h6><p>构造方法是使用new关键字创建一个时被调用的，构造方法时需注意：</p>
<p>(1)构造方法名与类名相同。</p>
<p>(2)构造方法没有返回值类型。</p>
<p>(3)构造方法中不能使用return返回一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person0</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person0</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法自动被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPersonDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;声明对象：Person p = null&quot;</span>);</span><br><span class="line">        <span class="type">Person0</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//声明对象时不调用构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实例化对象：p=new Person0()&quot;</span>);</span><br><span class="line">        p= <span class="keyword">new</span> <span class="title class_">Person0</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-构造方法的重载"><a href="#2-构造方法的重载" class="headerlink" title="2.构造方法的重载"></a>2.构造方法的重载</h6><p>与普通方法一样，只要每个构造方法的参数列表不同，即可实现重载。</p>
<h4 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3.this关键字"></a>3.this关键字</h4><p>类在定义成员方法时，局部变量和成员变量可以重名，但此时不能访问成员变量。为避免这种情形，Java提供了this关键字，表示当前对象，指向调用的对象本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">equals</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);             <span class="comment">//打印this的地址</span></span><br><span class="line">        System.out.println(p);               <span class="comment">//打印对象地址</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==p)                      <span class="comment">//判断当前对象与this是否相等</span></span><br><span class="line">            System.out.println(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThis</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.equals(p1);</span><br><span class="line">        p2.equals(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this关键字在程序中主要有三种用法，下面分别讲解各种用法。</p>
<h5 id="1-使用this调用类中的属性"><a href="#1-使用this调用类中的属性" class="headerlink" title="1.使用this调用类中的属性"></a>1.使用this调用类中的属性</h5><p>this关键字可以明确调用类的成员变量，不会与局部变量名发生冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person3</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefAttr</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person3</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person3</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法的形参与成员变量同名，使用this明确调用成员变量，避免了与局部变量产生冲突。</span></span><br></pre></td></tr></table></figure>

<h5 id="2-使用this调用成员方法"><a href="#2-使用this调用成员方法" class="headerlink" title="2.使用this调用成员方法"></a>2.使用this调用成员方法</h5><p>this既然可以访问成员变量，那么也可以访问成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">        <span class="built_in">this</span>.log(<span class="string">&quot;Person.say&quot;</span>);   <span class="comment">// 明确使用this调用log()成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefFun</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-使用this调用构造方法"><a href="#3-使用this调用构造方法" class="headerlink" title="3.使用this调用构造方法"></a>3.使用this调用构造方法</h5><p>构造方法是在实例化时被自动调用的，因此不能直接像调用成员方法一样去调用构造方法，但可以使用this（[实参列表]）的方式调用其他的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//声明姓名私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;       <span class="comment">//声明年龄私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person5</span><span class="params">()</span>&#123;   <span class="comment">//这里的Person5()是构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person5</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();    <span class="comment">//此时调用的是没有返回值的Person5类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用有参构造函数&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;   <span class="comment">//明确表示为类中的name属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;    <span class="comment">//明确表示为类中的age属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;,年龄：&quot;</span>+<span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThisRefConstructor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person5</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);  <span class="comment">//调用Person5 含有两个参数的方法</span></span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，在使用this调用构造方法时，还需注意：在构造方法中，使用this调用构造方法的语句必须位于首行，且只能出现一次。</p>
<h4 id="4-static关键字"><a href="#4-static关键字" class="headerlink" title="4.static关键字"></a>4.static关键字</h4><h5 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1.静态变量"></a>1.静态变量</h5><p>使用static修饰的成员变量，称为静态变量或类变量，它被类的所有对象共享，属于整个类所有，因此可以通过类名直接访问。而未使用static修饰的成员变量称为实例变量，它属于具体对象独有，只能通过引用变量访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">//保存对象创建的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInstanceVariable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(p5.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出为1</span></span><br><span class="line"><span class="comment">由于实例变量count是属于类的对象的，对象之间的count是不相关的，它们被存储在不同的内存位置。因此程序运行结果输出的1是引用对象count值。要想实现用count记录类对象被创建的次数，可使用static关键字来修饰成员变量即可达到目的</span></span><br><span class="line"><span class="comment">将第2行代码更换成 static int count;即可实现最后输出5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注：static关键字在修饰变量的时候只能修饰成员变量，不能修饰方法中的局部变量。</p>
<h5 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h5><p>使用static修饰的成员方法，称为静态方法，无须创建类的实例就可以调用静态方法，静态方法可以通过类名调用。</p>
<p>静态方法只能访问类的静态成员（静态变量、静态方法），不能访问类中的实例成员（实例变量和实例方法）。这是因为未被static修饰的成员都是属于对象的，所以需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<h5 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h5><p>代码块是指用”{}”括起来的一段代码，根据位置和声明关键字不同，代码块分为普通、构造、静态、同步四种代码块。</p>
<p>普通代码块就是在方法名或方法体内用大括号”{}”括起来的一段代码。</p>
<p>构造代码块就是直接定义在类中的代码块，它没有任何前缀、后缀及关键字修饰。创建对象时，构造方法被自动调用，构造代码块也是在创建对象时被调用，但它在创造方法之前被调用，因此，构造代码块也可以用来初始化成员变量。另外，构造代码块会优先于构造方法执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Constructor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">()</span>&#123;              <span class="comment">//定义构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;                                  <span class="comment">//定义构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConstructorCodeBlock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块就是使用static关键字修饰的代码块，它是最早执行的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCodeBlock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticCodeBlock</span><span class="params">()</span>&#123;           <span class="comment">//定义构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;                                   <span class="comment">//定义构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;                             <span class="comment">//定义静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticCodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticCodeBlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h4><h5 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h5><p>成员内部类是指类作为外部类的一个成员，能直接访问外部类的所有成员，但在外部类中访问内部类，则需要在外部类中创建内部类的对象，使用内部类的对象来访问内部类中的成员。同时，若要在外部类外访问内部类，则需要通过外部类对象去创建内部类对象，在外部类创建一个内部类对象的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 引用变量名 = <span class="keyword">new</span> 外部类名().new 内部类名()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="comment">//定义类成员</span></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;Other&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">//定义内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Other.Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//内部类成员方法中访问外部类私有成员变量</span></span><br><span class="line">            <span class="comment">//Other.this表示外部类对象</span></span><br><span class="line">            System.out.println(Other.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;:&quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建内部类对象</span></span><br><span class="line">        Other.<span class="type">Inner</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        obj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a>2.静态内部类</h5><p>static关键字修饰的内部类称为静态内部类。静态内部类可以有实例成员和静态成员，它可以直接访问外部类的静态成员，但如果想访问外部类的实例成员，就必须通过外部类的对象去访问。另外，如果在外部类外访问静态内部类成员，则不需要创建外部类对象，只需创建内部类对象即可。</p>
<p>创建内部类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 引用变量名 = <span class="keyword">new</span> 外部类名.内部类名()</span><br></pre></td></tr></table></figure>

<h5 id="3-方法内部类"><a href="#3-方法内部类" class="headerlink" title="3.方法内部类"></a>3.方法内部类</h5><p>在成员方法中定义的类，它与局部变量类似，作用域为定义它的代码块，因此它只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。</p>
<h5 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.匿名内部类</h5><p>匿名内部类就是没有名称的内部类。创建匿名内部类时会创建一个该类的对象，该类定义立即消失，匿名内部类不能重复使用。</p>
<h4 id="6-类的继承"><a href="#6-类的继承" class="headerlink" title="6.类的继承"></a>6.类的继承</h4><h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;</span><br><span class="line">    属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java使用extends关键字指明两个类之间的继承关系。子类继承了父类中的属性和方法，也可以添加新的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> property;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;的年龄&quot;</span>+property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayAge</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;的年龄:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtends</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Child对象</span></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        <span class="comment">//Child对象本身没有name成员变量</span></span><br><span class="line">        <span class="comment">//因为Child父类有name成员变量，所以Child继承了父类的成员变量和方法</span></span><br><span class="line">        c.name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        c.property=<span class="number">100</span>;</span><br><span class="line">        c.age=<span class="number">20</span>;</span><br><span class="line">        c.say();</span><br><span class="line">        c.sayAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Child类通过extends关键字继承了Parent类，继承了其所有的成员，且可以扩展功能。</p>
<p>但Java语言只支持单继承，不允许多重继承，即一个子类只能继承一个父类，否则会引发编译错误。</p>
<p>但它支持多层继承，即一个类的父类可以继承另外的父类。因此，java类可以有无限多个间接父类。</p>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-重写父类方法"><a href="#2-重写父类方法" class="headerlink" title="2.重写父类方法"></a>2.重写父类方法</h5><p>在进行方法重写时必须考虑权限，即被子类重写的方法不能拥有比父类方法更加严格的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父辈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> <span class="keyword">extends</span> <span class="title class_">Parent1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子女&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//闯进Child对象</span></span><br><span class="line">        <span class="type">Child1</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child1</span>();</span><br><span class="line">        c.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：子女 说明重写成功</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>(1)方法的重载是在同一个类中，方法的重写是在子类与父类中。</p>
<p>(2)方法重载要求：方法名相同，参数个数或参数类型不同。</p>
<p>(3)方法重写要求：子类与父类的方法名、返回值类型和参数列表相同。</p>
<h5 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3.super关键字"></a>3.super关键字</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.成员变量</span><br><span class="line"><span class="built_in">super</span>.成员方法([实参列表])</span><br></pre></td></tr></table></figure>

<p>super可以实现调用父类被重写的成员方法，可以在子类中访问被隐藏的父类成员。</p>
<p>子类继承父类时，并没有继承父类的构造方法，但子类构造方法可以调用父类的构造方法。在一个构造方法中调用另一个重组在的构造方法时应使用this关键字，在子类构造方法中调用父类的构造方法时应使用super关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>([参数列表])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父辈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> <span class="keyword">extends</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSuperRefConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Child对象</span></span><br><span class="line">        <span class="type">Child2</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        c.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，如果子类中没有显式地调用父类的构造方法，那么将自动调用父类中不带参数的构造方法。 </p>
<h5 id="4-final关键字"><a href="#4-final关键字" class="headerlink" title="4.final关键字"></a>4.final关键字</h5><p>在Java中，为了考虑安全因素，要求某些类不允许被继承或者不允许被子类修改，这时可以用final关键字修饰。</p>
<p>(1)final修饰的类不能被继承</p>
<p>(2)final修饰的方法不能被子类重写。</p>
<p>(3)final修饰的变量是常量，初始化后不能再修改。</p>
<p>使用final关键字修饰的类称为最终类，表示不能再被其他类继承，如Java中的String类</p>
<p>使用final关键词修饰的方法，称为最终方法，表示子类不能再重写此方法</p>
<p>使用final关键词修饰的变量，称为常量，只能赋值一次。再次对该变量进行赋值时，程序在编译时会报错。</p>
<h4 id="7-抽象类和接口"><a href="#7-抽象类和接口" class="headerlink" title="7.抽象类和接口"></a>7.抽象类和接口</h4><h5 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h5><p>Java中可以定义不含方法体的方法，方法的方法体由该类的子类根据实际需求去实现，这样的方法称为抽象方法，包括抽象方法的类必须是抽象类。</p>
<p>Java中提供了abstract关键字，表示抽象的意思，用abstract修饰的方法，称为抽象方法，是一个不完整的方法，只有方法的声明，没有方法体。用abstract修饰的类，称为抽象类。抽象类可以不包含任何抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用abstract修饰抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="comment">//abstract修饰抽象方法，只有声明，没有实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类不能被实例化，即不能用new关键字创建对象。因此，必须通过子类继承抽象去实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用abstract修饰抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent5</span> &#123;</span><br><span class="line">    <span class="comment">//abstract修饰抽象方法，只有声明，没有实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child5</span> <span class="keyword">extends</span> <span class="title class_">Parent5</span> &#123;</span><br><span class="line">    <span class="comment">//实现抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAbstractClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">            <span class="type">Child5</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Child5</span>();</span><br><span class="line">            c.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，具体子类必须实现抽象父类中的所有抽象方法，否则子类必须要声明为抽象类</p>
<p>另外，抽象方法不能用static来修饰，因为static修饰的方法可以通过类名调用，调用将调用一个没有方法体的方法，肯定会出错；抽象方法也不能用final关键字修饰，因为被final关键字修饰的方法不能被重写，而抽象方法的实现需要在子类中实现；抽象方法也饿不能用private关键字修饰，因为子类不能访问带private关键字的抽象方法。</p>
<p>抽象类中可以定义构造方法，因为抽象类仍然使用的是类继承关系，而且抽象类也可以定义成员变量。因此，子类在实例化时必须先对抽象类进行实例化。</p>
<h5 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h5><p>接口是全局常量和公共抽象方法的集合，可被看作一种特殊的类，也属于引用类型。每个接口都被编译成独立的字节码文件。Java提供interface关键字，用于声明接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface接口名&#123;</span><br><span class="line">    全局常量声明</span><br><span class="line">    抽象方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来演示interface关键字的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用interface声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;                  <span class="comment">//等价于public static final String name;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;                   <span class="comment">//等价于public abstract void say();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中定义的变量和方法都包含默认的修饰符，其中定义的变量默认声明为”public static final”，即全局常量。另外，定义的方法默认声明为”public abstract”，即抽象方法。</p>
<h6 id="1-接口的实现"><a href="#1-接口的实现" class="headerlink" title="1.接口的实现"></a>1.接口的实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口列表&#123;</span><br><span class="line">    属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用implements实现两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Parent&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImplements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        c.say();</span><br><span class="line">        c.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 接口名 extends 接口列表&#123;</span><br><span class="line">    全局常量声明</span><br><span class="line">    抽象方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用interface声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用extends继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用implements实现两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterfaceExtend</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">            Child c=<span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">            c.say();</span><br><span class="line">            c.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h4><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在Java中指把类中具有相似功能的不同方法使用同一个方法名实现，从而可以使用相同的方式来调用这些具有不同功能的同名方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Parent类继承Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> <span class="keyword">extends</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Child类实现Parent类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> <span class="keyword">extends</span> <span class="title class_">Parent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPolymorphism</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义Person类型引用变量</span></span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//使用Person类型变量引用Parent对象</span></span><br><span class="line">        p=<span class="keyword">new</span> <span class="title class_">Parent2</span>();</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">//使用Person类型变量引用Child对象</span></span><br><span class="line">        p=<span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">//使用Parent类型变量引用Child对象</span></span><br><span class="line">        Parent2 p2=<span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">        p2.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态绑定机制原理是：当调用实例方法时，Java虚拟机从该变量的实际类型开始，沿着继承链向上查找该方法的实现，直到找到为止，并调用首次找到的实现。</p>
<p>对象的类型转换是指可以将一个对象的类型转换成继承结构中的另一种类型。类型转换分两种：</p>
<p>(1)向上转型，是从子类到父类的转换，也称隐式转换。</p>
<p>(2)向下转型，是从父类到子类的转换，也称显示转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Parent类继承Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Child类继承Parent类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTypeCast</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();               <span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">o</span> <span class="operator">=</span> (Parent)p;                 <span class="comment">//向下转型</span></span><br><span class="line">        o.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Object类"><a href="#9-Object类" class="headerlink" title="9.Object类"></a>9.Object类</h4><p>Java中提供一个Object类，是所有类的父亲。如果一个类没有显式地指定继承类，则该类的父类默认为Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在Object类中提供了很多方法</p>
<h5 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1.toString()方法"></a>1.toString()方法</h5><p>调用一个对象的toString()方法会默认返回一个描述该对象的字符串，它由该对象的所属类名、@和对象十六进制形式的内存地址组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> S</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-equals-方法"><a href="#2-equals-方法" class="headerlink" title="2.equals()方法"></a>2.equals()方法</h5><p>equals（）方法是用于测试两个对象是否相等</p>
<p>equals()方法与直接使用&#x3D;&#x3D;运算符检测两个对象结果相同，比较的是地址</p>
<h4 id="10-工厂设计模式"><a href="#10-工厂设计模式" class="headerlink" title="10.工厂设计模式"></a>10.工厂设计模式</h4><h5 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h5><p>简单工厂模式又称静态工厂方法，它的核心是类中包含一个静态方法，该方法用于根据参数来决定返回实现同一接口不同类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LearnJava2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dec</span> 描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义安卓手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Android</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;安卓手机被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义苹果手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iphone</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Iphone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果手机被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">factory</span><span class="params">(String className)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Android&quot;</span>.equals(className))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Iphone&quot;</span>.equals(className))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iphone</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSimpleFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//根据不同的参数生成产品</span></span><br><span class="line">        SimpleFactory.factory(<span class="string">&quot;Android&quot;</span>);</span><br><span class="line">        SimpleFactory.factory(<span class="string">&quot;Iphone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h5><p>工厂方法模式为工厂类定义了接口，用多态来削弱了工厂类的职责</p>
<h5 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h5><p>抽象工厂模式用于意在创建一系列互相关联或互相依赖的对象</p>
<h4 id="11-包"><a href="#11-包" class="headerlink" title="11.包"></a>11.包</h4><h5 id="1-包的定义与使用"><a href="#1-包的定义与使用" class="headerlink" title="1.包的定义与使用"></a>1.包的定义与使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包是Java提供的一种区别类的名字空间的机制，是类的组织方式，是一组相关类和接口的集合，它提供了访问权限和命名的管理机制。</p>
<p>需注意：</p>
<ul>
<li>包名中字母一般都要小写。</li>
<li>包的命名规则：将公司域名反转作为包名</li>
<li>package语句必须是程序代码中的第一行可执行代码</li>
<li>package语句最多只有一句</li>
</ul>
<p>包与文件目录类似，可以分成多级，多级之间用”.”符号进行分隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.1000phone.www;</span><br></pre></td></tr></table></figure>

<p>如果在程序中已声明了包，就必须将编译生成的字节码文件保存到与包名同名的子目录中，可以使用带包编译命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -d .Source.java</span><br></pre></td></tr></table></figure>

<p>其中”-d”表示生成以package定义为准的目录，”.”表示在当前所在的文件夹中生成。编译器会自动在当前目录下建立与包名同名的子目录，并将生成的.class文件自动保存到与包名同名的子目录下。</p>
<h5 id="2-import语句"><a href="#2-import语句" class="headerlink" title="2.import语句"></a>2.import语句</h5><p>import关键字用于导入指定包层次下的某个类或全部类，import语句应放在package语句之后，类定义之前，其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名     <span class="comment">//导入单类</span></span><br><span class="line"><span class="keyword">import</span> 包名.*       <span class="comment">//导入包层次下的全部类</span></span><br></pre></td></tr></table></figure>

<h5 id="3-给Java应用程序打包"><a href="#3-给Java应用程序打包" class="headerlink" title="3.给Java应用程序打包"></a>3.给Java应用程序打包</h5><p>在实际开发中，通常会将一些类提供给别人使用，直接提供字节码文件会比较麻烦，所以一般会将这些类文件打包成jar文件，以供别人使用。jar文件的全称是Java Archive File，意思就是Java归档文件，也称为jar包。将一个jar包添加到classpath环境变量中，Java虚拟机会自动解压jar包，根据包名所对应的目录结构去查找所需的类</p>
<p>通常使用jar命令来打包，可以把一个或多个路径压缩成一个jar文件。jar命令在JDK安装目录下的bin目录中，直接在命令行中输入jar命令，即可查看jar命令的提示信息</p>
<p>jar命令主要参数如下：</p>
<p>(1)c:创建新的文档</p>
<p>(2)v:生成详细的输出信息。</p>
<p>(3)f:指定归档的文件名</p>
<h4 id="12-Lambda表达式"><a href="#12-Lambda表达式" class="headerlink" title="12.Lambda表达式"></a>12.Lambda表达式</h4><p>“-&gt;”可以称作箭头操作符或者Lambda操作符。当使用Lambda表达式进行代码编写的时候就需要使用这个操作符。箭头操作符将Lambda表达式分成左右两部分，在操作符的左侧代表着Lambda表达式的参数列表（接口中抽象方法的参数列表），在操作符的右侧代表着Lambda表达式中所需执行的功能（是对抽象方法的具体实现）Lambda表达式的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters)-&gt;experssion或(parameters) -&gt;&#123;statements;&#125;</span><br></pre></td></tr></table></figure>

<p>上述语法还可以写成：</p>
<p>无参数无返回值：()-&gt;具体实现</p>
<p>有一个参数无返回值:(x)-&gt;具体实现，或x-&gt;具体实现</p>
<p>有多个参数，有返回值，并且Lambda体重有多条语句：（x，y）-&gt;{具体实现}</p>
<p>若方法体只有一条语句，那么大括号和return都可以省略</p>
<h3 id="九-异常"><a href="#九-异常" class="headerlink" title="九.异常"></a>九.异常</h3><p>异常是一个在程序执行期间发生的事件，它中断了正在执行程序的正常指令流。在程序中，错误可能产生于程序员没有预料到各种情况或是超出了程序员可控范围的环境因素，为了保证程序有效地执行，需要对发生的异常进行相应的处理。</p>
<h4 id="1-异常的类型"><a href="#1-异常的类型" class="headerlink" title="1.异常的类型"></a>1.异常的类型</h4><ol>
<li>Error类：Throwable的一个子类，代表错误，该体系描述了Java运行系统中的内部错误以及资源耗尽的情形。该类错误是由Java虚拟机抛出的，如果发生，除了尽力使程序安全退出外，在其他方面是无能为力的。</li>
<li>Exception类是另外一个重要的子类，它规定的异常是程序自身可以处理的异常。异常和错误的区别在于异常是可以被处理的，而错误是不能够被处理的。</li>
</ol>
<h4 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2.异常的处理"></a>2.异常的处理</h4><h5 id="1-使用try-catch处理异常"><a href="#1-使用try-catch处理异常" class="headerlink" title="1.使用try-catch处理异常"></a>1.使用try-catch处理异常</h5><p>异常捕获结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;                 <span class="comment">//捕获异常，该块用于监控可能发生异常的代码块是否发生异常，如果异常发生了   </span></span><br><span class="line">    程序代码<span class="number">1</span>          <span class="comment">//就会将产生的异常类对象抛出，并转向catch中继续执行。</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e1)&#123;      <span class="comment">//处理异常，一个try块后面可以有多个catch块，每个catch块可以处理的异常类型</span></span><br><span class="line">    程序代码<span class="number">2</span>          <span class="comment">//由异常处理器参数指定。</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e2)&#123;</span><br><span class="line">    程序代码<span class="number">3</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;               <span class="comment">//进行最终处理，不管程序是否发生异常最终都会执行的代码块。当包含catch子句</span></span><br><span class="line">    程序代码<span class="number">4</span>           <span class="comment">//时，finally字句是可选的；当包含finally字句时，catch子句是可选的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管程序是否发生异常，还是在try块中使用return语句结束，finally块都会执行。</p>
<h5 id="2-使用throws关键字抛出异常"><a href="#2-使用throws关键字抛出异常" class="headerlink" title="2.使用throws关键字抛出异常"></a>2.使用throws关键字抛出异常</h5><p>如果方法不捕获被检查出的异常，那么方法必须声明它可以抛出的这些异常，用于告知调用者此方法有异常。Java通过throws子句表明方法可抛出的所有异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 方法名(形参列表)<span class="keyword">throws</span> 异常类<span class="number">1</span>,异常类,...,异常类n&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws声明的方法表示此方法不处理异常，而交给方法的调用者进行处理。因此，不管方法是否发生异常，调用者都必须进行异常处理。</p>
<h5 id="3-使用throw关键字抛出异常"><a href="#3-使用throw关键字抛出异常" class="headerlink" title="3.使用throw关键字抛出异常"></a>3.使用throw关键字抛出异常</h5><p>针对用户希望能亲自进行异常类对象的实例化操作，自己手动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常对象();</span><br></pre></td></tr></table></figure>

<h4 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h4><p>在特定的问题领域，可通过扩展Exception类或RuntimeException类来创建自定义的异常。异常类包含和异常相关的信息，这有助于负责捕获异常的catch代码块准确地分析并处理异常。</p>
<p>(1)创建自定义异常类并继承Exception基类，如果自定义Runtime异常，则继承RuntimeException基类</p>
<p>(2)此方法中通过throw关键字抛出异常对象。</p>
<p>(3)如果在当前抛出异常的方法中处理异常，可以使用try-catch语句块捕获并处理，否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</p>
<p>(4)在出现异常方法的调用者中捕获并处理异常。</p>
<h4 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h4><p>断言语句用于确保程序的正确性，以避免逻辑错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> 布尔表达式;</span><br><span class="line"><span class="keyword">assert</span> 布尔表达式:消息;</span><br></pre></td></tr></table></figure>

<p>使用第一种格式，当布尔类型表达式值为false时，抛出AssertionError异常，如果使用第二种格式，则输出错误消息。在默认情况下，断言不起作用，可用-ea选项激活断言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -ea类名</span><br><span class="line">java -ea:包名 -da:类名</span><br></pre></td></tr></table></figure>

<h3 id="十-多线程"><a href="#十-多线程" class="headerlink" title="十.多线程"></a>十.多线程</h3><p>线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为线程，这些线程可以同时存在、同时运行，一个进程可能包含多个同时执行的线程</p>
<p>进程是程序的一次动态执行过程，需要经历从代码加载、代码执行到执行完毕的一个完整过程，这个过程也是进程本身从产生、发展到最终消亡的过程。每个运行中的程序就是一个进程。一般而言，进程在系统中独立存在，拥有自己独立的资源，多个进程可以在单个处理器上并发执行且互不影响。</p>
<p>操作系统可以同时执行多个进程，进程可以同时执行多个任务，其中每个任务就是线程。eg.杀毒软件程序是一个进程，那么它在喂计算机体检的同时可以清理垃圾文件，这就是两个线程同时运行。</p>
<h4 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1.线程的创建"></a>1.线程的创建</h4><h5 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承Thread类创建线程</h5><p>Java提供了Thread类代表线程，它位与java.lang包中</p>
<p>(1)定义Thread类的子类，并重写run()方法，run()方法称为线程执行体。</p>
<p>(2)创建Thread子类的实例，即创建了线程对象。</p>
<p>(3)调用线程对象的start()方法启动线程。</p>
<p>启动一个新线程时，需要创建一个Thread类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread1</span>();         <span class="comment">//创建SubThread1实例</span></span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread1</span>();</span><br><span class="line">        st1.start();                        <span class="comment">//开启线程</span></span><br><span class="line">        st2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;                     <span class="comment">//重写run()方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.current().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h5><p>(1)定义Runnable接口实现类，并重写run()方法</p>
<p>(2)创建Runnable实现类的示例，并将实例对象传给Thread类的target来创建线程对象。</p>
<p>(3)调用线程对象的start()方法启动线程。</p>
<h5 id="3-使用Callable接口和Futrue接口创建线程"><a href="#3-使用Callable接口和Futrue接口创建线程" class="headerlink" title="3.使用Callable接口和Futrue接口创建线程"></a>3.使用Callable接口和Futrue接口创建线程</h5><p>重写run()方法实现功能代码有一定局限性，这样做方法没有返回值且不能抛出异常</p>
<p>Java提供了Callable接口来解决这样的问题，接口内有一个call()方法可以作为线程执行体，call()方法有返回值且可以抛出异常。</p>
<p>(1)定义</p>
]]></content>
      <categories>
        <category>复习资料</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2.7.14下的单元测试环境搭建</title>
    <url>/2024/08/06/Vue2.7.14%E4%B8%8B%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Vue2-7-14下的单元测试环境搭建"><a href="#Vue2-7-14下的单元测试环境搭建" class="headerlink" title="Vue2.7.14下的单元测试环境搭建"></a>Vue2.7.14下的单元测试环境搭建</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><blockquote>
<p>vue”: “^2.7.14”,</p>
<p>“@babel&#x2F;preset-env”: “~7.24.5”,</p>
<p>“babel-core”: “~6.26.3”,</p>
<p>“@vue&#x2F;compiler-dom”: “~3.4.26”,</p>
<p>“@vue&#x2F;compiler-dom”: “~3.4.26”,</p>
<p>“@vue&#x2F;test-utils”: “~1.3.6”,</p>
<p>“babel-jest”: “~29.7.0”,</p>
<p>“babel-preset-env”: “~1.7.0”,</p>
<p>“jest”: “~29.7.0”,</p>
<p>“jest-environment-jsdom”: “~29.7.0”,</p>
<p>“jest-serializer-vue”: “~3.1.0”,</p>
<p>“jest-transform-stub”: “~2.0.0”,</p>
<p>“jsdom”: “16.7.0”,</p>
<p>“vue-jest”: “~3.0.7”,</p>
<p>“vue-server-renderer”: “2.7.16”,</p>
</blockquote>
<p>安装依赖：</p>
<p><code>npm install @babel/preset-env babel-core @vue/compiler-dom @vue/test-utils babel-jest babel-preset-env jest jest-environment-jsdom jest-serializer-vue jest-transform-stub jsdom vue-jest vue-server-renderer</code></p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="新增-修改-babelrc配置"><a href="#新增-修改-babelrc配置" class="headerlink" title="新增&#x2F;修改.babelrc配置"></a>新增&#x2F;修改<code>.babelrc</code>配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立测试文件夹"><a href="#建立测试文件夹" class="headerlink" title="建立测试文件夹"></a>建立测试文件夹</h3><p>根目录下建立test目录，test里面再按照如下建立对应文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20240506160930645.png" alt="image-20240506160930645"></p>
<p>其中<code>jest.conf.js</code>文件配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">testEnvironment</span>: <span class="string">&#x27;jsdom&#x27;</span>, <span class="comment">// 测试环境</span></span><br><span class="line">    <span class="attr">verbose</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">testURL</span>: <span class="string">&#x27;http://localhost/&#x27;</span>,</span><br><span class="line">    <span class="attr">rootDir</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../../&#x27;</span>),</span><br><span class="line">    <span class="attr">moduleFileExtensions</span>: [</span><br><span class="line">        <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">moduleNameMapper</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;^@\/(.*?\.?(js|vue)?|)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span>,   <span class="comment">// @路径转换，例如：@/components/Main.vue -&gt; rootDir/src/components/Main.vue</span></span><br><span class="line">        <span class="string">&#x27;\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/test/unit/__mocks__/fileMock.js&#x27;</span>, <span class="comment">// 模拟加载静态文件</span></span><br><span class="line">        <span class="string">&#x27;\\.(css|less|scss|sass)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/test/unit/__mocks__/styleMock.js&#x27;</span>　　<span class="comment">// 模拟加载样式文件   </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">testMatch</span>: [ <span class="comment">//匹配测试用例的文件</span></span><br><span class="line">        <span class="string">&#x27;&lt;rootDir&gt;/test/unit/specs/*.spec.js&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">transform</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;^.+\\.js$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/babel-jest&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.*\\.(vue)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/node_modules/vue-jest&#x27;</span></span><br><span class="line">        <span class="comment">// &quot;.+\\.(css|styl|less|sass|scss|png|jpg|ttf|woff|woff2)$&quot;: &quot;jest-transform-stub&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">testPathIgnorePatterns</span>: [</span><br><span class="line">        <span class="string">&#x27;&lt;rootDir&gt;/test/e2e&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// setupFiles: [&#x27;&lt;rootDir&gt;/test/unit/setup&#x27;],</span></span><br><span class="line">    <span class="attr">snapshotSerializers</span>: [<span class="string">&#x27;&lt;rootDir&gt;/node_modules/jest-serializer-vue&#x27;</span>],</span><br><span class="line">    <span class="attr">coverageDirectory</span>: <span class="string">&#x27;&lt;rootDir&gt;/test/unit/coverage&#x27;</span>, <span class="comment">// 覆盖率报告的目录</span></span><br><span class="line">    <span class="attr">collectCoverageFrom</span>: [ <span class="comment">// 测试报告想要覆盖那些文件，目录，前面加！是避开这些文件</span></span><br><span class="line">        <span class="comment">// &#x27;src/components/**/*.(js|vue)&#x27;,</span></span><br><span class="line">        <span class="string">&#x27;src/components/*.(vue)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;!src/main.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;!src/router/index.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;!**/node_modules/**&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.eslintrc</code>文件配置;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;env&quot;: &#123; </span><br><span class="line">    &quot;jest&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__mocks__ </code>文件目录下建立 <code>fileMock.js</code>,用来处理测试中遇到的静态资源， 内容就一行代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;test-file-stub&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>__mocks__ </code>文件目录下建立 <code>axios.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">get</span>: jest.<span class="title function_">fn</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123; <span class="attr">status</span>: <span class="number">200</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加测试命令"><a href="#添加测试命令" class="headerlink" title="添加测试命令"></a>添加测试命令</h3><p>在<code>package.json</code> 的 <code>scripts</code> 里添加测试命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;</span><br></pre></td></tr></table></figure>

<p>如果不需要计算单测覆盖率的话可以去掉<code>--coverage</code></p>
<h2 id="编写测试用例代码"><a href="#编写测试用例代码" class="headerlink" title="编写测试用例代码"></a>编写测试用例代码</h2><p>在<code>specs</code>下写测试用例代码</p>
<p>eg. <code>HelloWorld.spec.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;显示默认的问候语&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">HelloWorld</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;VueUtils&#x27;</span>, wrapper.<span class="title function_">find</span>(<span class="string">&#x27;h1&#x27;</span>).<span class="title function_">text</span>())</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;h1&#x27;</span>).<span class="title function_">text</span>()).<span class="title function_">toBe</span>(<span class="string">&#x27;Hello, Vue!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;点击按钮后，问候语应该变为&quot;Hola, Vue!&quot;&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">HelloWorld</span>)</span><br><span class="line">    wrapper.<span class="title function_">find</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">find</span>(<span class="string">&#x27;h1&#x27;</span>).<span class="title function_">text</span>()).<span class="title function_">toBe</span>(<span class="string">&#x27;Hola, Vue!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h2><p>执行 <code>npm run unit</code> 就可以启动测试了</p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的Diff算法的理解</title>
    <url>/2023/11/15/vue%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="vue中的Diff算法的理解"><a href="#vue中的Diff算法的理解" class="headerlink" title="vue中的Diff算法的理解"></a>vue中的Diff算法的理解</h1><h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><p>虚拟dom：表示真实DOM的JS对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20231113145619788.png" alt="image-20231113145619788"></p>
<p><strong>Diff算法是一种对比算法</strong>。对比两者是<code>旧虚拟DOM和新虚拟DOM</code>，对比出是哪个<code>虚拟节点</code>更改了，找出这个<code>虚拟节点</code>，并只更新这个虚拟节点所对应的<code>真实节点</code>，而不用更新其他数据没发生改变的节点，实现<code>精准</code>地更新真实DOM，进而<code>提高效率</code>。</p>
<p><code>使用虚拟DOM算法的损耗计算</code>： 总损耗 &#x3D; 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</p>
<p><code>直接操作真实DOM的损耗计算</code>： 总损耗 &#x3D; 真实DOM完全增删改+（可能较多的节点）排版与重绘</p>
<h2 id="Diff算法的原理"><a href="#Diff算法的原理" class="headerlink" title="Diff算法的原理"></a>Diff算法的原理</h2><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/5ca3d338e5a445ab80e40042c50ac79a~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="截屏2021-08-08 上午11.32.47.png"></p>
<h3 id="Diff对比流程"><a href="#Diff对比流程" class="headerlink" title="Diff对比流程"></a>Diff对比流程</h3><p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实DOM打补丁，更新相应的视图。</p>
<p><code>newVnode和oldVnode</code>：同层的新旧虚拟节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="截屏2021-08-08 上午11.49.38.png"></p>
<h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p>
<ul>
<li>是：继续执行<code>patchVnode方法</code>进行深层比对</li>
<li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li>
</ul>
<p><code>patch</code>的核心原理代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 比较是否为一个类型的节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldVnode, newVnode)) &#123;</span><br><span class="line">    <span class="comment">// 是：继续进行深层比较</span></span><br><span class="line">    <span class="title function_">patchVnode</span>(oldVnode, newVnode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否</span></span><br><span class="line">    <span class="keyword">const</span> oldEl = oldVnode.<span class="property">el</span> <span class="comment">// 旧虚拟节点的真实DOM节点</span></span><br><span class="line">    <span class="keyword">const</span> parentEle = api.<span class="title function_">parentNode</span>(oldEl) <span class="comment">// 获取父节点</span></span><br><span class="line">    <span class="title function_">createEle</span>(newVnode) <span class="comment">// 创建新虚拟节点对应的真实DOM节点</span></span><br><span class="line">    <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">      api.<span class="title function_">insertBefore</span>(parentEle, vnode.<span class="property">el</span>, api.<span class="title function_">nextSibling</span>(oEl)) <span class="comment">// 将新元素添加进父元素</span></span><br><span class="line">      api.<span class="title function_">removeChild</span>(parentEle, oldVnode.<span class="property">el</span>)  <span class="comment">// 移除以前的旧元素节点</span></span><br><span class="line">      <span class="comment">// 设置null，释放内存</span></span><br><span class="line">      oldVnode = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newVnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sameVnode方法"><a href="#sameVnode方法" class="headerlink" title="sameVnode方法"></a>sameVnode方法</h3><p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code>，那问题来了，怎么才算是同一类型节点呢？这个<code>类型</code>的标准是什么呢？</p>
<p>sameVnode方法的核心原理代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    oldVnode.<span class="property">key</span> === newVnode.<span class="property">key</span> &amp;&amp; <span class="comment">// key值是否一样</span></span><br><span class="line">    oldVnode.<span class="property">tagName</span> === newVnode.<span class="property">tagName</span> &amp;&amp; <span class="comment">// 标签名是否一样</span></span><br><span class="line">    oldVnode.<span class="property">isComment</span> === newVnode.<span class="property">isComment</span> &amp;&amp; <span class="comment">// 是否都为注释节点</span></span><br><span class="line">    <span class="title function_">isDef</span>(oldVnode.<span class="property">data</span>) === <span class="title function_">isDef</span>(newVnode.<span class="property">data</span>) &amp;&amp; <span class="comment">// 是否都定义了data</span></span><br><span class="line">    <span class="title function_">sameInputType</span>(oldVnode, newVnode) <span class="comment">// 当标签为input时，type必须是否相同</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="patchVnode方法"><a href="#patchVnode方法" class="headerlink" title="patchVnode方法"></a>patchVnode方法</h3><p>这个函数做了以下事情：</p>
<ul>
<li>找到对应的<code>真实DOM</code>，称为<code>el</code></li>
<li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li>
<li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li>
<li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li>
</ul>
<h3 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h3><p>这是<code>patchVnode</code>里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在<code>updateChildren方法</code>中，接下来就结合一些图来讲，让大家更好理解吧</p>
<p>是怎么样一个对比方法呢？就是<code>首尾指针法</code>，新的子节点集合和旧的子节点集合，各有首尾两个指针。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">修改数据后</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么新旧两个子节点集合以及其首尾指针为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/3eb33b1b28e7461f9aedb857736a142c~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="截屏2021-08-08 下午2.55.26.png"></p>
<p>然后会进行互相进行比较，总共有五种比较情况：</p>
<ul>
<li>1、<code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li>
<li>2、<code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li>
<li>3、<code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li>
<li>4、<code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li>
<li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/727b5dd8a3424d22afd9dc5cf0dae05e~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="截屏2021-08-08 下午2.57.22.png"></p>
]]></content>
      <categories>
        <category>个人经验文章</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>JS基于原型的继承理解</title>
    <url>/2025/03/13/JS%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="JS基于原型的继承理解"><a href="#JS基于原型的继承理解" class="headerlink" title="JS基于原型的继承理解"></a>JS基于原型的继承理解</h1><h2 id="原型＆原型链"><a href="#原型＆原型链" class="headerlink" title="原型＆原型链"></a>原型＆原型链</h2><p>JavaScript 只有一种结构：对象。每个对象（object）都有一个私有属性指向另一个名为<strong>原型</strong>（prototype）的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>（prototype chain）中的最后一个环节。</p>
<p>JavaScript 对象是动态的属性（指<strong>其自有属性</strong>）“包”。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">student.<span class="property">_proto_</span> === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> </span><br><span class="line"><span class="comment">//  隐式原型             显示原型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">drink</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喝水&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,subject</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subject</span> = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">teach</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是$(this.name),教$(this.subject)。`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&#x27;哈默&#x27;</span>,<span class="string">&#x27;前端开发&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teacher&#x27;</span>,teacher);</span><br><span class="line">teacher.<span class="title function_">teach</span>();</span><br><span class="line">teacher.<span class="title function_">drink</span>();</span><br></pre></td></tr></table></figure>

<p>代码对应原型链如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20231106141020167.png" alt="image-20231106141020167"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>super关键字：</p>
<p>super 关键字用于访问和调用一个对象的父对象上的函数。在构造函数中使用时，super关键字将单独出现，并且必须在使用 this 关键字之前使用。super 关键字也可以用来调用父对象上的函数。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">super</span>(<span class="variable language_">arguments</span>);  <span class="comment">// 调用父构造函数</span></span><br><span class="line"><span class="variable language_">super</span>.<span class="title function_">parentMethod</span>(<span class="variable language_">arguments</span>);  <span class="comment">// 调用父方法</span></span><br></pre></td></tr></table></figure>

<p>在类中使用super实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">height, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Rectangle&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hi, I am a &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">area</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_area</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Polygon</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里，它调用父类的构造函数的，</span></span><br><span class="line">    <span class="comment">// 作为 Polygon 的 height, width</span></span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">      </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span>; <span class="comment">// 需要放在 super 后面，不然引发 ReferenceErro</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注意：在派生的类中，在你可以使用&#x27;this&#x27;之前，必须先调用 super()。</span></span><br><span class="line">    <span class="comment">// 忽略这，这将导致引用错误。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>自学资料</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>从SSR到ESR的前端渲染方式探索</title>
    <url>/2024/08/06/%E4%BB%8ESSR%E5%88%B0ESR%E7%9A%84%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="从SSR到ESR的前端渲染方式探索"><a href="#从SSR到ESR的前端渲染方式探索" class="headerlink" title="从SSR到ESR的前端渲染方式探索"></a>从SSR到ESR的前端渲染方式探索</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 web 页面来说，首跳场景（例如 SEO、付费引流）的性能普遍比二跳场景下要差。原因有多种，主要是首跳用户在连接复用，和本地资源缓存利用方面，有很大的劣势。首跳场景下，很多在端上的优化手段（预加载，预执行，预渲染等）无法实施。</p>
<p>在客户端缓存能力无法利用的情况下，利用 cdn 距离用户近的特性，可以结合缓存做一些性能优化。</p>
<h3 id="SSR（Server-Side-Rendering）"><a href="#SSR（Server-Side-Rendering）" class="headerlink" title="SSR（Server Side Rendering）"></a>SSR（Server Side Rendering）</h3><p>为了性能优化考虑，我们一般都会通过服务端渲染（SSR） ，将首屏动态内容直接服务端输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1460000022762251" alt="image.png"></p>
<p>这种方式的优点是一次 html 返回即可包含页面主体内容，不需要浏览器二次请求接口后再用 js 渲染。但这种方式的缺点也比较明显，对于距离服务端远，或者服务端处理时间较长的场景，用户会看到较长时间的白屏。而且即使 html 返回完成了，用户并不会立即看到内容，页面还需要加载前置的 js，css 等资源后，才能看到内容。</p>
<p>缺点：</p>
<ul>
<li>⾮常依赖服务端的处理时间</li>
<li>需要加载js 、css 、图⽚等静态资源， ⽩屏时间⻓</li>
</ul>
<h3 id="CSR（Client-Side-Rendering）"><a href="#CSR（Client-Side-Rendering）" class="headerlink" title="CSR（Client Side Rendering）"></a>CSR（Client Side Rendering）</h3><p>为了减少白屏时间，考虑利用 CDN 的边缘缓存能力，可以把页面 html 直接缓存在 cdn 节点上。但对于大部分场景来说，页面的主体内容都是动态，或者个性化的，把全部 html 内容缓存在 cdn 上对于业务影响较大，很有少场景能接受。那么换个思路，只把 html 静态部分缓存在 cdn 上呢？其实这个思路也是一个很常见的操作，即把 html 的静态框架部分缓存在 cdn 上，让用户能快速看到部分内容，然后再在客户端发起异步请求，获取动态内容并且渲染（CSR）。CSR + CDN 模式下的渲染时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1460000022762254" alt="image.png"></p>
<p>这种方式的优点是页面静态框架缓存在 cdn 上，用户可以快速看到页面框架内容，减少白屏等待焦虑。</p>
<p>缺点：<strong>完整的页面内容需要再执行 js ，拉取异步接口回来后再进行渲染。最终有意义的动态内容展示出来的时间，比 SSR 更晚。</strong></p>
<h3 id="ESI-Edge-Side-Include"><a href="#ESI-Edge-Side-Include" class="headerlink" title="ESI (Edge Side Include)"></a>ESI (Edge Side Include)</h3><p>CSR + CDN 的方式，很好地解决了白屏时间问题，但带来了动态内容展示的延时。之所以有这个问题，是因为我们把页面的动态内容和静态内容分割到了两个阶段中，并且是串行的，而且串行过程中还穿插了 js 的下载和执行。有什么办法把动态内容和静态内容在 CDN 上整合起来呢？</p>
<p>ESI (Edge Side Include) 给了我们一个很好的思路启发，ESI 最初也是 CDN 服务商们提出的规范，可通过 html 标签里加特定的动态标签，可让页面的静态内容缓存在 cdn 上，动态内容可以自由组装。ESI 的渲染时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1460000022762253" alt="image.png"></p>
<p>缺点：</p>
<ul>
<li>返回给⽤户的⾸字节也是需要等请求响应， 并且等所有动态内容在CDN上拼接完成 。 没有减少⽩屏时间， 实际上与SSR⼀样。</li>
<li>会出现cdn域名劫持⻛险</li>
</ul>
<h3 id="ESR（Edge-Side-Rendering）"><a href="#ESR（Edge-Side-Rendering）" class="headerlink" title="ESR（Edge Side Rendering）"></a>ESR（Edge Side Rendering）</h3><p>在 ESI (Edge Side Include) 的基础上，提出了一种新的优化思路：边缘流式渲染方案（ESR），即借助 CDN 的边缘计算能力，将静态内容与动态内容以流式的方式，先后返回给用户。</p>
<p>我们可以将页面进行动静拆分，将静态内容缓存在 CDN 先快速返回给用户，然后在边缘计算节点上发起动态内容的请求，之后将动态内容与静态部分以流的形式进行拼接，从而进一步提高了用户的首屏加载时间，尤其在边缘地区或者弱网环境也有能拥有很好的用户体验，此外还减少原先 SSR 服务器压力。最终页面渲染的时序图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1460000022762256" alt="image.png"></p>
<h2 id="边缘渲染原理和优势"><a href="#边缘渲染原理和优势" class="headerlink" title="边缘渲染原理和优势"></a>边缘渲染原理和优势</h2><p>边缘渲染就是借助边缘计算能力，将返回的内容进行静态+动态部分拆分并以流的形式返回，最终实现渲染提速。其中，静态部分依托 CDN 的缓存能力，优先返回给用户，随后在边缘计算节点上继续发起动态数据请求，并拼接在静态部分之后，继续流式返回。因此，其优势也是显而易见：</p>
<ol>
<li>TTFB(Time To First Byte)很短：因为静态内容在 CDN 缓存住了，会很快的返回给用户。</li>
<li>FP(First Paint)很短：因为在静态内容返回后，已经可以开始 HTML 的解析以及 JS、CSS 的下载和执行。</li>
<li>FMP(First Meaningful Paint)很短：因为动态内容的请求是在边缘计算节点发起，相比于客户端与服务端直连，请求减少了 TCP 建连和网络传输开销，而且由于动态部分是以 chunked 形式流式返回，FMP 就会很短，比如搜索网站的第一个搜索结果就会首先绘制出来。</li>
<li>边缘节点与服务端之间的网络，相比于客户端与服务端之间的网络，更有优化空间。例如通过动态加速，以及 edge 与 server 之间的连接复用，能为动态请求减少 tcp 建连和网络传输开销。以做到最终动态内容的返回时间，比 client 直接访问 server 更快。</li>
</ol>
<p>总体而言，相对于传统中心渲染，边缘渲染具有节点分布较广，距离用户更近等优势，让用户可以在更短的时间获取到网站资源进行渲染，同时可以减少中心服务的请求压力，从而达到渲染提速+分散算力的效果。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/view" alt="preview"></p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>前端响应式的实现</title>
    <url>/2025/03/13/%E5%89%8D%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前端响应式的实现"><a href="#前端响应式的实现" class="headerlink" title="前端响应式的实现"></a>前端响应式的实现</h1><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<p>一般会用到的属性：</p>
<ul>
<li>flex-direction:设置Flex容器中子元素的排列方向</li>
<li>flex-wrap:设置Flex容器中子元素的换行方式</li>
<li>flex-flow:设置Flex容器中子元素的排列方向和换行方式</li>
<li>justify-content:设置Flex容器中子元素在主轴上的对齐方式</li>
<li>align-items：用于设置Flex容器中子元素在交叉轴上的对齐方式。</li>
<li>align-content：用于设置多行或多列的Flex容器中子元素在交叉轴上的对齐方式</li>
</ul>
<h2 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h2><p>比如，当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。</p>
<ul>
<li>height、width 属性的百分比依托于父标签的宽高。但是 padding、border、margin 等属性的情况又不一样</li>
<li>1、子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位（默认定位）的父元素的高度，同样，子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位（默认定位的）父元素的宽度。 2、子元素的 padding 和 margin 如果设置百分比，不论是垂直方向或者是水平方向都相对于直接父亲元素的 width，而与父元素的 height 无关。</li>
<li>border-radius 为百分比，则是相对于自身的宽度</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</p>
<h2 id="媒体查询布局"><a href="#媒体查询布局" class="headerlink" title="媒体查询布局"></a>媒体查询布局</h2><p>通过@media 媒体查询，可以通过给不同屏幕的大小编写不同的样式来实现响应式的布局。</p>
<p>响应式缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</p>
<p>另外有一个缺省值<code>mediatype</code> 有四种值：</p>
<ul>
<li>all：适用于所有设备(默认值)</li>
<li>screen：屏幕（电脑、平板、手机等）</li>
<li>print：打印机和打印预览</li>
<li>speech：语音设备（屏幕阅读器等）</li>
</ul>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><h3 id="rem-如何适配"><a href="#rem-如何适配" class="headerlink" title="rem 如何适配"></a>rem 如何适配</h3><ul>
<li><p>rem 是相对于 html 根元素的字体大小的单位。</p>
</li>
<li><p>我们通过修改 html 中 font-size 的字体大小来控制 rem 的大小。</p>
</li>
<li><p>当 html 中 font-size: 10px; 时，此时 1rem &#x3D; 10px，所以 box 盒子的宽高分别为：100px 和 200px;</p>
</li>
<li><p>当我们把 html 中 font-size: 20px; 时，此时 1rem &#x3D; 20px,此时 box 盒子的宽高就为 200px 和 400px;</p>
</li>
</ul>
<h3 id="实际开发中如何适配，如何将设计稿对应的-px-单位转换为-rem-单位"><a href="#实际开发中如何适配，如何将设计稿对应的-px-单位转换为-rem-单位" class="headerlink" title="实际开发中如何适配，如何将设计稿对应的 px 单位转换为 rem 单位"></a>实际开发中如何适配，如何将设计稿对应的 px 单位转换为 rem 单位</h3><ul>
<li><p>在实际的开发中，我们通常会以 750px 的移动端设计稿来开发。</p>
</li>
<li><p>我们在代码写完后，统一会把所有 px 单位全部转成 rem 来实现。</p>
</li>
<li><p>以上单位的转换，我们可以利用 vscode 的插件 px to rem 来自动实现。</p>
</li>
<li><p>把所有代码全部写完，然后一次性用 px to rem 插件转换成 rem 单位</p>
</li>
</ul>
<h3 id="接下来如何适配不同的浏览器，实现等比例的缩放呢-？"><a href="#接下来如何适配不同的浏览器，实现等比例的缩放呢-？" class="headerlink" title="接下来如何适配不同的浏览器，实现等比例的缩放呢 ？"></a>接下来如何适配不同的浏览器，实现等比例的缩放呢 ？</h3><ul>
<li>比如现在有 5 个同尺寸的屏幕 （750 640 480 375 320），所有屏幕整体宽分成 10rem</li>
<li>那我们就需要分别得到这几种不同屏幕下对应的 html 根元素的 font-size 大小了。</li>
</ul>
<h2 id="vw、vh-响应式布局"><a href="#vw、vh-响应式布局" class="headerlink" title="vw、vh 响应式布局"></a>vw、vh 响应式布局</h2><p>vw 和 vh 分别相对的是视图窗口的宽度和视口窗的高度。</p>
<ul>
<li>100vw &#x3D; 视图窗宽度 ，100vh &#x3D; 100 视图窗高度</li>
<li>如果移动端有 5 个不同的视口宽尺寸 750 ，640，480，375，320，则在不同尺寸下，对应的 1vw 的 px 值如下表</li>
<li>移动端尺寸1vw750px7.5px640px6.4px480px4.8px375px3.75px320px320px<ul>
<li>我们在实际开发时，只需要按其中的某一个尺寸来的 px 单位的设计稿来开发就好（一般是以 750px 的大小为主）</li>
<li>代码全部开发好后，我们再利用 vscode 的插件 px to vw 来实现单位的自动转换。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>自学资料</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习笔记（部分）</title>
    <url>/2023/08/13/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前端笔记："><a href="#前端笔记：" class="headerlink" title="前端笔记："></a>前端笔记：</h1><h2 id="h5笔记："><a href="#h5笔记：" class="headerlink" title="h5笔记："></a>h5笔记：</h2><ol>
<li><p>英文状态下输入！可以直接跳出格式</p>
</li>
<li><p>UTF-8：万国码</p>
</li>
<li><p>head第二行没用，可以删去。</p>
</li>
<li><p>title内为网页名称</p>
</li>
<li><p>body内填网页内容</p>
</li>
<li><p><xxx>这是单标签 主要用于申明属性 <xxx></xxx> 主要用于输入内容</p>
</li>
<li><p>lang 后面写语言 en代表英语 可以直接删去</p>
</li>
<li><p>段落标签：<h1>-<h6> 段落和换行标签：<p>&lt;\p&gt; <br/></p>
<ol>
<li>水平线分割标签<hr/></li>
</ol>
</li>
<li><p>斜体<em><em/></p>
</li>
<li><p>加粗<strong></strong></p>
</li>
<li><p>结构标签<div></div> 、<span></span></p>
</li>
<li><p>图片标签：输入image src后面填写路径 alt后面是若图片出现异常无法显示而显示的文本 后面可以跟width设定宽度 height设置高度</p>
</li>
<li><p>超链接：a标签 herf后面跟网址 标签内内容填写超链接显示文字或者标签嵌套加入image标签做成图片超链接</p>
</li>
<li><p>锚链接：使用超链接实现 只是跳转到内部 所以跳转目标出设定一个id 然后a标签herf后写“#id名”即可</p>
</li>
<li><p>功能性发邮件&#x2F;打电话：也是以超链接形式实现 herf后写mailto：邮箱地址 实现发邮件 herf后写tel：电话号码实现打电话</p>
</li>
<li><p>块级元素：独占一行，换行显示，可以设置宽高，块可以套块和行。</p>
</li>
<li><p>行级元素：在行内显示，内容撑开宽高，不可以设置宽高（img、input除外），行只能套行。</p>
</li>
</ol>
<h2 id="css3笔记："><a href="#css3笔记：" class="headerlink" title="css3笔记："></a>css3笔记：</h2><ol>
<li>选择器{声明；属性：值；} 如<style>h1{color:red}</style> （标签选择器）</li>
<li><strong>颜色</strong>：color 字体大小：front-size</li>
<li><strong>类选择器</strong>：1.首先在标签中 定义类名 class&#x3D;“类名”多个标签的类名可以重复 因为类选择器目的就是选中多个 2.使用方法： .类名{声明；}</li>
<li><strong>id选择器</strong>：首先在标签中 定义id名 id&#x3D;“id名” 2.使用方法： #id名{声明；}</li>
<li><strong>id选择器和类型选择器的区别：</strong> id是唯一的 类不唯一</li>
<li><strong>标签选择器 &lt; 类选择器 &lt; id选择器</strong></li>
<li><strong>可以同时设置标签和id</strong></li>
<li>Html导入css的样式方法：1.<strong>内连样式：</strong>在head之前写css 2.<strong>内部样式</strong> 在每个标签内写 3.<strong>外联样式</strong>：直接新创建一个css文件 格式：选择器{声明；} 然后将新css文件和原html文件连接起来 连接方式：html文件head前加link 然后跳出框内herf后写css文件路径以及名字（链接式）</li>
<li>当前目录：.&#x2F;</li>
<li>第二种外联连接方式：head前加<style></style>里面用@import url（css文件路径以及名字）（导入式）</li>
<li>一般用链接式，导入式只能导入css样式，而且有些浏览器不兼容</li>
<li>样式优先级：内部&gt;内联？外联 取决于在head中 谁在下面，谁的样式起作用</li>
<li>设置字体样式：font-family 设置字体类型  font-style 设置字体风格italic（斜体） front-weight 设置字体粗细 font 可以设定所有属性</li>
<li>text-align 文本位置 left左对齐 right右对齐 center居中</li>
<li>设置字体颜色：color：颜色</li>
<li>background-color 背景颜色</li>
<li>line-height:行高 </li>
<li>text-decoration 文本装饰 underline（下划线）overline（上划线） line-through（中划线） none取消所有格式</li>
<li><strong>伪类语法：</strong>伪类名称：a:link（未单击访问时超链接形式） a:visited （单击访问后超链接形式） a:hover（鼠标悬浮其上的超链接样式） a:active（鼠标单击未释放） 内部可以加属性如color然后设定颜色</li>
<li><strong>css设定鼠标形状：</strong>default 默认光标 pointer 超链接的指针（手） wait（转圈等待的效果）help（指示可用的帮助） text（指示文本） crosshair（十字架）</li>
<li>在伪类语法中用cursor使用设定鼠标形状</li>
<li>span的作用类似小括号 用于改文本局部的样式</li>
<li>列表分为： 无序列表（ul） 有序列表（ol） 自定义列表（dl）</li>
<li>（在body内）使用列表分为两个步骤：申明列表类型 和申明列表项 </li>
<li>每个浏览器为列表设定的初边距不一样 所以需要style内加上*{margin：0；padding：0；}</li>
<li>有序列表会帮你排序 标上序号 若像倒叙 则在ol 后加reversed</li>
<li>更改序号类型可在ol后加type选择序号类型</li>
<li>设置起始序号 start&#x3D;“xx”</li>
<li>设置无序列表的类型：style中加list-style选择类型 none是取消·</li>
<li>自定义列表使用方法 dt后内容左对齐 dd相当于段落行</li>
<li>表格<table>标签  <tr></tr>行 <td></td>列</li>
<li>列合并：（标签内加入）colspan&#x3D;“合并几列”框内写合并框的内容</li>
<li>同样的原理 行合并：rowspan</li>
<li>表单：input标签 一般格式<input type="xxx"> xxx可以是text（文本）、password（密码···形式）、radio（选择圆圈）</li>
<li>Radio设置多选一可以把所有选项取相同名字 即都加name&#x3D;“xxx”</li>
<li>默认选中：标签内加checked&#x3D;“checked”</li>
<li>扩大选框选中的范围：1.给文字部分加一个label标签 for起名字 2.给input起一个和for后面名字相同的id名</li>
<li>复选框：type&#x3D;“checkbox”</li>
<li>按钮：type&#x3D;“botton” value后面写内容 或者<button>xxx</button></li>
<li>选择框下拉菜单：<select> <option>xxx…</select> xxx填写备选项 value后面写获取该选项时反馈的值</li>
<li>option&lt;&gt;内后可以加selected&#x3D;“selected”使该选项为默认选择</li>
<li>多行文本域（限制最大输入字数）：<textarea>xxx</textarea>标签 name后面写该多行文本域 cols：显示的行数 rows：显示的列数 xxx：文本内容 （但一般不用textarea）</li>
<li>使用input限制输入文字个数：利用maxlength属性 设定最大输入长度 在input类型是text或者password时适用</li>
<li>可以给input设置id 然后可以通过id选择器设置输入框宽高</li>
<li>隐藏域：type&#x3D;“hidden” 可以隐藏内容且不占空间 同时也可以<p hidden>隐藏段落</li>
<li>只读：readonly 在标签内加</li>
<li>禁用：（按钮变成灰色不可使用状态）一般使用于后期的判断 disabled 在标签内加</li>
<li>后代选择器：标签选择器下通过写一层层的标签 如li a{color：red；} 注：只要是后代，都发生变化</li>
<li>子代选择器：只有儿子生效 使用方法：类似于后代选择器 但用&gt;连接 如h1&gt;strong{color:red;}</li>
<li>并集选择器：用，连接标签选择器下的多个声明 可以联用子代选择器</li>
<li>交集选择器：用.连接标签选择器下的多个声明</li>
<li>属性选择器（只要具备某个属性，或者属性&#x3D;属性值，就会被选中执行某些操作）：在标签选择器下用[xxx]{}xxx是属性如herf 满足以下任意条件：1.具备某个属性 2.满足属性&#x3D;值 3.^&#x3D;‘’以什么字母开头 $&#x3D;‘’以什么字母结束 4.*&#x3D;“xxx”包含xxx</li>
<li>边框设置的四种样式：border属性：后面可以添加宽、线类型、颜色 线类型：solid（实线）、dashed（虚线）、double（双实线）、dotted（点状虚线）</li>
<li>如果只给了一个边框属性，那么则同时生效作用于元素的四个边框</li>
<li>若想让元素的四个边框不同，可以分别设置 如border-top border-bottom border-left border-right</li>
<li>将div变圆：border-radius属性 参数设置为50% 且div必须是正方形 否则是椭圆</li>
<li>将div变三角形：将div的width和height都设置为0px 设置四个边框不同颜色相同像素宽 将其他三个边框颜色设置为transparent（透明） 即可 （调高width或height可以变成梯形）</li>
<li>给元素设置外边距：margin参数 可以margin-bottom、margin-top……一个个单独设置 也可以直接margin后面跟四个参数值（依次为上右下左） 单位为px（像素） 另外，设置两个值的时候第一个值代表上下 第二个值代表左右</li>
<li>盒模型的计算大小：实际展示大小&#x3D;元素大小+边框+内边距</li>
<li>内边距：padding 用法和margin相同</li>
<li>怪异模式：box-sizing：border-box 增加内边距且不改变元素的大小</li>
<li>初始化css样式：不同浏览器初始格式不同 需要统一样式 则需要先初始化 即设置*{margin：0；padding：0；}</li>
<li>块元素：一定是独占一行，可以设置宽高。如ul、ol、li、form、div等</li>
<li>行内块元素：不独占一行，可以设置宽高。如button、img、input、select等</li>
<li>行内元素：不独占一行，可以设置宽高。如：span、a、label等</li>
<li>转换为行内元素：display：inline 转换为块元素：display：block 转换为行内块元素：display：inline-block</li>
<li>浮动：float  可以设定方向如float：left</li>
<li>元素浮动之后就脱离了标准文档流 </li>
<li>清除浮动的方法：1.给浮动的父元素加一个高度 2.给浮动下面建一个空白的div 起名叫clearfix，然后在选择器中设定clearfix下clear：both（或者clear：方向）</li>
<li>超出部分隐藏：overflow:xxx xxx可以是visible(默认值。内容不会被修建，会呈现在盒子之外) hidden（内容会被剪切，且其余内容不可见） scroll（内容会被修建，但浏览器会显示滚动条以便查看其余内容） auto(如果内容被剪切，则浏览器会显示滚动条以便查看其余内容)</li>
<li>定位：把元素放在我们指定的位置</li>
<li><strong>定位分类：</strong>static（默认值，没有定位） relative（相对定位） absolute（绝对定位)  fixed(固定定位)</li>
<li><strong>固定定位：</strong>滚轮滑动，显示的位置一直不变  参照物：浏览器屏幕  不占实际位置，位置会被下面元素占去</li>
<li>申明定位属性后，可以通过设定left、bottom（距离当前页面最底部的距离）、top、right的参数值来设定位置</li>
<li><strong>相对定位：</strong>滚轮滑动，位置随滑动改变。占实际位置，位置不会被下面元素占去 参照物：自身左上角的原点 </li>
<li><strong>绝对定位：</strong>脱离标准流 ，如果绝对元素的父元素没有设定过任意定位，参照物是最外面元素的左上角（浏览器的左上角），如果绝对元素的父元素有任意定位，参照物就是父元素的左上角。</li>
<li>子元素设定绝对定位，那一般父元素就设定相对定位</li>
<li><strong>z-index属性：</strong>整数，默认值为0 数字越大越优先显示 用于重叠的时候分层 最大值是2147483647 值相同的时候 谁的代码在下面谁优先显示，因为程序最后读到他</li>
<li>实现文本在div中上下居中：使用flex布局 display: flex;align-items: center;justify-content: space-around; flex-direction: column;</li>
<li></li>
</ol>
<h2 id="JS笔记："><a href="#JS笔记：" class="headerlink" title="JS笔记："></a>JS笔记：</h2><ol>
<li><p><strong>JavaScipt分为三个部分：</strong>ECMAScript、BOM、DOM。ECMAScipt：语言标准 BOM：浏览器对象模型，只要是浏览器给我提供的功能，前后退隐藏最小化最大关闭等统称为BOM DOM：文档对象模型，页面上显示的所有内容，统称为DOM</p>
</li>
<li><p>js文件代码的后缀就直接是.js</p>
</li>
<li><p><strong>Js代码引入的三种方式：</strong>外部、内部、行内。</p>
</li>
<li><p><strong>外部引入：</strong>使用<script>表现 在h5文件的head中利用<script src="xxx"></script> xxx为js文件地址</p>
</li>
<li><p><strong>内部样式：</strong>在script双标签之间填入js内容 可以放在head双标签之间 body双标签之间 body双标签之外</p>
</li>
<li><p><strong>标签内部嵌套：</strong>eg.&lt;button onclick&#x3D;“alert(xxx)”xxx</button></p>
</li>
<li><p><strong>js的方法：</strong>弹框输出方法：alert（‘弹出内容’(或者用””)）document.write(‘xxx’)直接显示</p>
</li>
</ol>
<p>声明变量：var 变量名&#x3D;值  赋值：等号后面的值赋值给等号前面的变量名 变量：常常变化的量</p>
<ol start="8">
<li><p>声明变量后，系统会立马在内存开辟一片空间。</p>
</li>
<li><p>声明变量如果不写var，解释器会自动帮你补全。</p>
</li>
<li><p>js中<strong>；</strong>代表结束</p>
</li>
<li><p>接受浏览器弹框输入：prompt（‘xxx’） xxx为内容（提示用户输入的信息）</p>
</li>
<li><p><strong>js的数据类型：</strong>undefined 当变量被申明时没有初识值，则将会被赋予undefined      null 表示一个空值，与undefined值相等    number 包含整数和浮点数    boolean 布尔型    string 被引号括起来的文本    object 属性的集合、每个属性都由‘名&#x2F;值’对构成 </p>
</li>
<li><p>只要变量值是‘’ 无论前面怎么定义变量类型 都是string类型</p>
</li>
<li><p>console.log(xxx) xxx为变量名 这是程序员调试用的 可以测试xxx的输出值</p>
</li>
<li><p>算术运算符：+、-、*、&#x2F;、%、++、–     赋值运算符：&#x3D;   比较运算符：&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</p>
</li>
<li><p>加法：对于A+B，如果一个是字符串，一个是数字类型，会拼接 ，如果都是数字类型，则会运算</p>
</li>
<li><p>减法：对变量隐式转换，只要能转换为number类型，全部转换为number类型，然后运算</p>
</li>
<li><p>如果无法转换为number类型，将不再运算 无法运算 返回结果NaN （not a number）</p>
</li>
<li><p>乘法、除法和减法一样</p>
</li>
<li><p>取余数的时候 如果被除数小于除数 取本身</p>
</li>
<li><p>取整 在需要取整的变量前加parseInt</p>
</li>
<li><p>小数 paseInt</p>
</li>
<li><p>&#x3D;&#x3D;只判断内容   &#x3D;&#x3D;&#x3D;不但判断值，还要判断数据类型 成立返回true 不成立返回false</p>
</li>
<li><p>++代表自增 –代表自减  ++在前，先自增，再运算 –在后，先运算，再自增</p>
</li>
<li><p>变量命名规则 严格区分大小写 不能以数字开头 不能是关键字、保留字 遵循驼峰命名法（首字母小写，后面单词的首字母需要大写）</p>
</li>
<li><p>typeof可用来获取检测变量的数据类型 可以加在console.log(xxx)中xxx的前面 则输出值为xxx的数据类型</p>
</li>
<li><p>if、if else、else if、switch、do-while、break语句用法和c语言相同</p>
</li>
<li><p>三元表达式（三目运算符）：条件表达式？表达式1：表达式2 如果条件表达式为真 则返回表达式1的值 如果条件表达式为假 则返回表达式2的值</p>
</li>
<li><p>声明函数语法结构：function 函数名（）{ 函数体 }  调用函数则直接使用函数名（）即可</p>
</li>
<li><p>我们可以利用函数的参数实现函数重复不同的代码（参照c语言的实参和形参的区别）</p>
</li>
<li><p>如果实参数量大于形参，则会忽略多余的实参用其他的进行运算 如果实参数量小于形参，意味着是数字加上undefined，结果是NaN</p>
</li>
<li><p>返回语句return语句和c语言用法相同</p>
</li>
<li><p>不知道有多少个参数传递时，可以用arguments来获取。arguments实际上是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中储存了传递的所有实参。</p>
<p>1.arguments展现形式是一个伪数组，因此可以遍历。具有特点：1.具有数组的length属性 2.按照索引的方式进行存储的3.它没有真正数组的一些方法pop（） push()等等</p>
<p>用法eg.function fn(){</p>
<p>console.log(agruments);</p>
<p>}</p>
<p>fn(1,2,3);</p>
</li>
<li><p>预解析：js引擎会把js里面所有的var还有function提升到当前作用域的最前面。</p>
</li>
<li><p>构造函数的语法格式：function 构造函数名(){</p>
<p>this.属性&#x3D;值；</p>
<p>this.方法&#x3D;function(){}</p>
<p>}</p>
</li>
<li><p>1.构造函数的名字首字母必须要大写 2.构造函数不需要return就可以返回结果 3.我们构造函数必须要使用new 4.我们只要new Star（）调用函数就创建了一个对象 5.我们的属性和方法前面必须添加this</p>
</li>
<li><p>对象：特指是一个具体的事物</p>
</li>
<li><p>我们利用构造函数创建对象的过程我们也称之为对象的实例化</p>
</li>
<li><p>new关键字执行过程：1.new构造函数可以在内存中创建一个空的对象  2.this就会指向刚才创建的空对象 3.执行构造函数的代码 给这个空对象添加属性和方法  4.返回这个对象</p>
</li>
<li><p>遍历对象：for（变量 in 对象）{   }</p>
</li>
<li><p>JS中的对象分为3种：自定义对象、内置对象、浏览器对象</p>
</li>
<li><p>通过查MDN文档可以查阅js的具体各内置对象用法</p>
</li>
<li><p>Math数学对象 不是一个构造函数，所以我们不需要new来调用 而是直接使用里面的属性和方法即可。</p>
</li>
<li><p>js中的四舍五入：其他数字都是四舍五入，只有.5是往大了取 如-1.5四舍五入后是-1</p>
</li>
<li><p><strong>window.onload()</strong> 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。</p>
</li>
<li><p>window.onload 事件绑定事件处理函数，绑定的是一个匿名函数，也可以绑定具名函数。</p>
<ol>
<li></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>自学资料</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>前端版本更新提示技术方案调研与实现</title>
    <url>/2024/08/06/%E5%89%8D%E7%AB%AF%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前端版本更新提示技术方案调研与实现"><a href="#前端版本更新提示技术方案调研与实现" class="headerlink" title="前端版本更新提示技术方案调研与实现"></a>前端版本更新提示技术方案调研与实现</h1><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>项目迭代频繁，如果用户打网页后，长时间不关闭对应标签页，也不刷新页面，而此期间有新的版本已经上线了，需要用户手动刷新，不然会出现一直使用旧版本以及会出现一些不可预知的错误</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>采取定时检查，定期向服务器发送请求，检查是否有新版本可用。</li>
<li>拦截页面的网络请求，并且在发现有新版本时，提示用户更新或者自动更新。</li>
<li>通过<code>WebSocket</code>连接实时接收到服务器的推送消息，如果有新版本可用，服务器可以通过<code>WebSocket</code>发送通知给客户端，提醒用户刷新页面。</li>
</ul>
<h2 id="主流实现方案"><a href="#主流实现方案" class="headerlink" title="主流实现方案"></a>主流实现方案</h2><h3 id="方案一-通过-ETag-获取应用版本"><a href="#方案一-通过-ETag-获取应用版本" class="headerlink" title="方案一 通过 ETag 获取应用版本"></a>方案一 通过 ETag 获取应用版本</h3><p><code>&quot;ETag&quot;(Entity Tag)</code>是HTTP标头的一部分，用于标识网络资源的版本。它通常与<code>HTTP</code>缓存机制一起使用，以便客户端可以在后续请求中使用<code>ETag</code>来检查资源是否已经发生了变化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722917837011.png" alt="1722917837011"></p>
<h4 id="ETag的生成"><a href="#ETag的生成" class="headerlink" title="ETag的生成"></a>ETag的生成</h4><ul>
<li><p>对于静态文件(如css、js、图片等)，<code>ETag</code>的生成策略是:文件大小的16进制+修改时间</p>
</li>
<li><p>对于字符串或<code>Buffer</code>，<code>ETag</code>的生成策略是:字符串&#x2F;<code>Buffer</code>长度的16进制+对应的<code>hash</code>值</p>
</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>我们可以通过 <code>fetch</code> 请求获取当前应用的 <code>etag</code> 标签:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(location.<span class="property">href</span>, &#123;<span class="attr">method</span>: <span class="string">&#x27;HEAD&#x27;</span>,<span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;etag&#x27;</span>))&#125;)</span><br></pre></td></tr></table></figure>

<p>当应用新版本发布后， <code>etag</code> 的值也会更新。所以，我们可以通过比较 <code>etag</code> 的值来判断是否有新版本发布。</p>
<p>通过<code>Web Worker</code>来轮询最新的ETag:</p>
<p><code>version-worker.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.<span class="property">onmessage</span>=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    /!获取当前版本的<span class="title class_">ETag</span>值currentETag</span><br><span class="line">    <span class="keyword">const</span> currentETag = e.<span class="property">data</span>.<span class="property">currentETag</span></span><br><span class="line">    <span class="comment">// 设置定时器，每隔3秒向指定的checkurl发送HEAD请求//当服务器返回的ETag值与currentETag不相同时，向主线程发送消息&#x27;has new version&#x27;setInterval(()=&gt;&#123;</span></span><br><span class="line">    <span class="title function_">fetch</span>(e.<span class="property">data</span>.<span class="property">checkUrl</span>,&#123;<span class="attr">method</span>: <span class="string">&#x27;HEAD&#x27;</span></span><br><span class="line">                           <span class="attr">cache</span>:<span class="string">&#x27;no-cache</span></span><br><span class="line"><span class="string">                          &#125;).then((res)=&gt;&#123;if(res.headers.get(&#x27;</span>etag<span class="string">&#x27;)!= currentETag)&#123;self.postMessage(&#x27;</span>has <span class="keyword">new</span> version<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">                                                                                    子)</span></span><br><span class="line"><span class="string">                                                                                   &#125;，3000)</span></span><br></pre></td></tr></table></figure>

<p>主页代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 创建worker</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;version-worker.js&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 接收版本⽐较结果</span></span></span><br><span class="line"><span class="language-javascript">            myWorker.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                myWorker.<span class="title function_">terminate</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> result = <span class="title function_">confirm</span>(<span class="string">&#x27;有新版本，是否更新&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (result) &#123;</span></span><br><span class="line"><span class="language-javascript">                    location.<span class="title function_">reload</span>()</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取当前版本并发送给worker</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">fetch</span>(location.<span class="property">href</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>: <span class="string">&#x27;HEAD&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                myWorker.<span class="title function_">postMessage</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">checkUrl</span>: location.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">currentETag</span>: res.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;etag&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主页面获取当前 <code>etag</code> 值后，发送消息给 <code>worker</code> ， <code>worker</code> 将会异步的定时请求最新的<code>etag</code>值，并进行比较，当<code>etag</code>值不⼀致时会发送消息给主页。主页面接受到新版本发布消息后，可对用户进行提醒。</p>
<h4 id="相关第三方组件version-polling"><a href="#相关第三方组件version-polling" class="headerlink" title="相关第三方组件version-polling"></a>相关第三方组件<code>version-polling</code></h4><blockquote>
<p>仓库地址：<a href="https://github.com/JoeshuTT/version-polling">https://github.com/JoeshuTT/version-polling</a></p>
<p>安装： npm install version-polling –save</p>
</blockquote>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><ol>
<li>使用<code> Web Worker APl</code>在浏览器后台轮询请求页面，不会影响主线程运行。</li>
<li>命中协商缓存，对比本地和服务器请求响应头<code>etag</code>字段值。</li>
<li>如果 <code>etag</code> 值不一致，说明有更新，则弹出更新提示，并引导用户手动刷新页面(例如弹窗提示)，完成应用更新。</li>
<li>当页面不可见时(例如切换标签页或最小化窗口)，停止实时检测任务;再次可见时(例如切换回标签页或还原窗口)，恢复实时检测任务。</li>
</ol>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><h6 id="方法一-通过-npm-引入，并通过构建工具进行打包"><a href="#方法一-通过-npm-引入，并通过构建工具进行打包" class="headerlink" title="方法一 通过 npm 引入，并通过构建工具进行打包"></a>方法一 通过 <code>npm</code> 引入，并通过构建工具进行打包</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在应用入口文件中使用:如 main.js，app.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVersionPolling &#125; <span class="keyword">from</span> <span class="string">&quot;version-polling&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createVersionPolling</span>(&#123;</span><br><span class="line">    <span class="attr">appETagKey</span>:<span class="string">&quot;_APP_ETAG__&quot;</span>,</span><br><span class="line">    <span class="attr">pollingInterval</span>:<span class="number">5</span>*<span class="number">1000</span>，<span class="comment">//单位为毫秒</span></span><br><span class="line">    <span class="attr">silent</span>:process.<span class="property">env</span>.<span class="property">NODE_ENV</span> ===<span class="string">&quot;development&quot;</span>，<span class="comment">//开发环境下不检测</span></span><br><span class="line">    <span class="attr">onUpdate</span>:<span class="function">(<span class="params">self</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//当检测到有新版本时，执行的回调函数，可以在这里提示用户刷新页面</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title function_">confirm</span>(<span class="string">&quot;页面有更新，点击确定刷新页面!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(result)&#123;</span><br><span class="line">        self.<span class="title function_">onRefresh</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        self.<span class="title function_">oncancel</span>();</span><br><span class="line">        <span class="comment">//强制更新可以用alert</span></span><br><span class="line">        <span class="comment">// alert(&#x27;有新版本，请刷新页面”);</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="方法二-通过-script-引⼊，直接插⼊到-HTML（无侵入用法，接入成本最低）"><a href="#方法二-通过-script-引⼊，直接插⼊到-HTML（无侵入用法，接入成本最低）" class="headerlink" title="方法二 通过 script 引⼊，直接插⼊到 HTML（无侵入用法，接入成本最低）"></a>方法二 通过<code> script</code> 引⼊，直接插⼊到 <code>HTML</code>（无侵入用法，接入成本最低）</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>前端页面自动检测更新<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/version-polling/dist/version-polling.min.js&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">&lt;/scri</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                <span class="title class_">VersionPolling</span>.<span class="title function_">createVersionPolling</span>(&#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                <span class="attr">appETagKey</span>: <span class="string">&quot;__APP_ETAG__&quot;</span>,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                <span class="attr">pollingInterval</span>: <span class="number">5</span> * <span class="number">1000</span>,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                <span class="attr">onUpdate</span>: <span class="function">(<span class="params">self</span>) =&gt;</span> &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                    <span class="comment">// 当检测到有新版本时，执⾏的回调函数，可以在这里页面</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                    <span class="keyword">const</span> result = <span class="title function_">confirm</span>(<span class="string">&quot;页面有更新，点击确定刷新页面！&quot;</span>);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                    <span class="keyword">if</span> (result) &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                        self.<span class="title function_">onRefresh</span>();</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                    &#125; <span class="keyword">else</span> &#123;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                        self.<span class="title function_">onCancel</span>();</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                    &#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">                &#125;,</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">            &#125;);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">        </span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>version-polling 需要在⽀持 web worker 和 fetchAPI 的浏览器中运⾏，不⽀持 IE 浏览器</li>
<li>version-polling 需要在 web 应⽤的⼊⼝⽂件（通常是 index.html）中引⼊，否则⽆法检测到更新</li>
<li>version-polling 需要在 web 应⽤的服务端配置协商缓存，否则⽆法命中缓存，会增加⽹络请求</li>
<li>version-polling 需要在 web 应⽤的服务端保证每次发版后，index.html ⽂件的 etag 字段值会改变，否则⽆法检测到更新</li>
</ul>
<h4 id="方案缺陷"><a href="#方案缺陷" class="headerlink" title="方案缺陷"></a>方案缺陷</h4><ul>
<li><p><strong>频繁的轮询请求，且每次请求Size大</strong>:即使应用程序没有更新也会消耗网络带宽和服务器资源，可能会对性能产生负面影响，尤其是在大量用户同时访问的情况下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722921251786.png"></p>
</li>
<li><p><strong>无法实时推送更新：</strong>使用轮询方式无法实现实时推送更新的功能。轮询方式通常有一定的时间间隔，用户只能等待下一次轮询请求才能收到更新通知。这种延迟可能会导致用户错过重要的更新或者在使用过时版本时遇到问题。</p>
</li>
</ul>
<h3 id="方案二-提取版本号保存至json文件，客户端轮询服务器上的版本号"><a href="#方案二-提取版本号保存至json文件，客户端轮询服务器上的版本号" class="headerlink" title="方案二 提取版本号保存至json文件，客户端轮询服务器上的版本号"></a>方案二 提取版本号保存至json文件，客户端轮询服务器上的版本号</h3><p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722921319728.png" alt="1722921319728"></p>
<p>以 <code>git commit hash</code>(也支持<code>svn revision number</code>、<code>package.json version.build timestamp </code>、<code>custom</code>)为版本号，打包时将版本号写入一个 <code>json</code>文件，同时注入客户端运行的代码。客户端轮询服务器上的版本号（浏览器窗口的<code>visibilitychange</code>、<code>focus</code> 事件辅助)，和本地作比较，如果不相同则通知用户刷新页面。</p>
<h4 id="相关第三方组件-plugin-web-update-notification"><a href="#相关第三方组件-plugin-web-update-notification" class="headerlink" title="相关第三方组件 plugin-web-update-notification"></a>相关第三方组件 <code>plugin-web-update-notification</code></h4><blockquote>
<p>仓库:<a href="https://github,com/GreatAuk/plugin-web-update-notification">https://github,com/GreatAuk/plugin-web-update-notification</a></p>
<p>安装:(可以使用npm安装)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vite</span></span><br><span class="line">pnpm add @plugin<span class="literal">-web-update-notification</span>/vite <span class="literal">-D</span></span><br><span class="line"><span class="comment"># umijs</span></span><br><span class="line">pnpm add @plugin<span class="literal">-web-update-notification</span>/umijs <span class="literal">-D</span></span><br><span class="line"><span class="comment"># webpack plugin</span></span><br><span class="line">pnpm add @plugin<span class="literal">-web-update-notification</span>/webpack <span class="literal">-D</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>接入简单，安装插件，修改配置文件即可，不用修改业务代码(如果不自定义行为)</li>
<li>支持多种版本号类型(<code>git commit hash</code>、<code>svn revision number</code>、<code>package.js</code>中的 <code>version</code> 字段、 <code>build timestamp</code> 运行打包命令时的时间戳、<code>custom</code> 用户自定义版本可以自定义更新提示的文案、样式、位置，且支持多语言，也可以取消默认的 <code>Notification</code>,监听到更新事件后自定义行为。</li>
<li>支持手动控制检测</li>
<li>注入的<code> js</code> 和<code>css</code> 文件压缩后不到2kb</li>
<li>完善的 <code>ts</code> 类型提示</li>
<li><code>issue</code> 响应即时</li>
</ul>
<h5 id="基于项目的实践项目采用vue-cli进行打包"><a href="#基于项目的实践项目采用vue-cli进行打包" class="headerlink" title="基于项目的实践项目采用vue-cli进行打包"></a>基于项目的实践项目采用<code>vue-cli</code>进行打包</h5><p>安装第三方组件后，在 <code>vue.config.js</code> 文件中加入:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WebUpdateNotificationPlugin</span> &#125; = <span class="built_in">require</span>(@plugin-web-update-notification/vite<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">const &#123; defineConfig &#125; = require(&#x27;</span>@vue/cli-service<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">module.exports = &#123;</span></span><br><span class="line"><span class="string">    // ...other config</span></span><br><span class="line"><span class="string">    configureWebpack: &#123;</span></span><br><span class="line"><span class="string">        resolve: &#123;</span></span><br><span class="line"><span class="string">            // ...other config</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        plugins: [</span></span><br><span class="line"><span class="string">            new WebUpdateNotificationPlugin(&#123;</span></span><br><span class="line"><span class="string">                logVersion: true,</span></span><br><span class="line"><span class="string">                versionType: &#x27;</span>git_commit_hash<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                checkInterval: 0.5 * 60 * 1000,</span></span><br><span class="line"><span class="string">                checkOnWindowFocus: true,</span></span><br><span class="line"><span class="string">                checkImmediately: true,</span></span><br><span class="line"><span class="string">                checkOnLoadFileError: true,</span></span><br><span class="line"><span class="string">                notificationConfig: &#123;</span></span><br><span class="line"><span class="string">                    placement: &#x27;</span>topRight<span class="string">&#x27;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                notificationProps: &#123;</span></span><br><span class="line"><span class="string">                    title: &#x27;</span>页面已经发生了更新<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                    description: &#x27;</span>检测到当前页面内容已经发生了更新，请刷新页面后使用<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                    buttonText: &#x27;</span>刷新<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                    dismissButtonText: &#x27;</span>忽略<span class="string">&#x27;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">            &#125;),</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h6><p>运行打包命令 <code>yarn run build</code></p>
<p>dist目录下多了⼀个⽂件夹，包含含有版本号的<code>JSON</code>文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722923207539.png" alt="1722923207539"></p>
<p>更新提示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20240806140346695.png" alt="image-20240806140346695"></p>
<h6 id="检测更新的时机"><a href="#检测更新的时机" class="headerlink" title="检测更新的时机"></a>检测更新的时机</h6><ol>
<li>首次加载页面。</li>
<li>轮询(default:10 * 60 * 1000 ms)</li>
<li>js 脚本资源加载失败 (404 ?)</li>
<li>标签页 <code>visibilitychange</code>、<code>focus</code> 事件为<code> true</code> 时。</li>
</ol>
<h4 id="自实现方法"><a href="#自实现方法" class="headerlink" title="自实现方法"></a>自实现方法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>用 <code>git</code> 命令提取当前最新的 <code>cmt id</code></li>
<li>把 <code>cmt id</code> 写入到一个文件里，这个文件会被轮询</li>
<li>把 <code>cmt id</code> 写入到 <code>index.html</code>里</li>
<li>在 <code>main.js</code> 里去轮询写入了 <code>cmt id</code> 的文件，拿来和 <code>html</code> 里进行对比</li>
<li>如果 <code>html</code> 存在 <code>cmt id</code> ，且轮询到了<code>cmt id</code> ，然后两个 <code>cmt id</code> 不相等，则提示更新</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722923475645.png" alt="1722923475645"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722923497761.png" alt="1722923497761"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>通过<code>git</code>命令将最新的<code>cmt id</code> 注入<code>latest_commit id.txt</code> 文件中:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git rev<span class="literal">-parse</span> HEAD &gt; latest_commit_id.txt</span><br></pre></td></tr></table></figure>

<p>编写 <code>html/updateIndex.js</code> <code>node</code> 脚本文件，用于动态获取 <code>commit id</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="comment">// 使⽤ git 命令获取最新 commit id</span></span><br><span class="line"><span class="keyword">const</span> latestCommitId = <span class="title function_">execSync</span>(<span class="string">&#x27;git rev-parse HEAD&#x27;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>();</span><br><span class="line"><span class="comment">// 将最新 commit id 写⼊ index.html ⽂件</span></span><br><span class="line"><span class="keyword">let</span> indexHtml = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">indexHtml = indexHtml.<span class="title function_">replace</span>(</span><br><span class="line"><span class="string">&#x27;window.latestCommitId = &quot;&quot;;&#x27;</span>,</span><br><span class="line"><span class="string">`window.latestCommitId = &quot;<span class="subst">$&#123;latestCommitId&#125;</span>&quot;;`</span></span><br><span class="line">);</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;index.html&#x27;</span>, indexHtml);</span><br><span class="line"><span class="comment">// 将最新 commit id 写⼊ latest_commit_id.txt ⽂件</span></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;latest_commit_id.txt&#x27;</span>, latestCommitId);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最新 commit id 已插⼊到 index.html 和 latest_commit_id.txt ⽂件中。&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>并加入在 <code>package.json</code> 打包命令中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service serve &amp;&amp; node ./html/updateIndex.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service build &amp;&amp; node ./html/updateIndex.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>编辑 <code>html/index.html</code> 文件，加入轮询代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">latestCommitId</span> = <span class="string">&quot;&quot;</span>; <span class="comment">// 替换为动态获取的 commit id</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加 <code>src/common/updateCheck.js</code> 文件，进行轮询操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UpdateModal</span> <span class="keyword">from</span> <span class="string">&#x27;./UpdateModal.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ⽴即查询⼀次最新的 commit ID</span></span><br><span class="line">    <span class="title function_">fetchLatestCommitId</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，每隔10分钟查询⼀次最新的 commit ID</span></span><br><span class="line">    <span class="built_in">setInterval</span>(fetchLatestCommitId, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchLatestCommitId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/latest_commit_id.txt&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">newCommitId</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> currentCommitId = <span class="variable language_">window</span>.<span class="property">latestCommitId</span></span><br><span class="line">        <span class="keyword">if</span> (currentCommitId &amp;&amp; currentCommitId !== newCommitId) &#123;</span><br><span class="line">            <span class="comment">// 提⽰更新</span></span><br><span class="line">            <span class="title function_">showUpdateModal</span>(newCommitId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showUpdateModal</span>(<span class="params">newCommitId</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">UpdateModalComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">UpdateModal</span>)</span><br><span class="line">    <span class="keyword">const</span> updateModalInstance = <span class="keyword">new</span> <span class="title class_">UpdateModalComponent</span>(&#123;</span><br><span class="line">        <span class="attr">propsData</span>: &#123; newCommitId &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.$destroy()</span><br><span class="line">                div.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(div)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">refresh</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    updateModalInstance.$mount(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>DOMContentLoaded</code> 来确保在操作页面元素之前等待页面加载完成</p>
<p>可见只轮询一个txt文件size要小很多</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/image-20240806135721956.png" alt="image-20240806135721956"></p>
<p>添加 <code>updateModal.vue</code> 文件，编写弹框的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;update-modal&quot; v-if=&quot;!isClosed&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;发现新版本&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;⽹⻚更新啦！请刷新⻚⾯后使⽤&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;actions&quot;&gt;</span><br><span class="line">        &lt;a @click=&quot;ignore&quot; class=&quot;web-update-notice-refresh-btn&quot;&gt;忽略&lt;/a&gt;</span><br><span class="line">        &lt;a @click=&quot;refresh&quot; class=&quot;web-update-notice-dismiss-btn&quot;&gt;刷新&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            newCommitId: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                required: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isClosed: false,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ignore() &#123;</span><br><span class="line">                this.isClosed = true // 设置 isClosed 为 true 以关闭模态框</span><br><span class="line">                this.$emit(&#x27;close&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            refresh() &#123;</span><br><span class="line">                this.$emit(&#x27;refresh&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .update-modal &#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        bottom: 15%;</span><br><span class="line">        right: 3%;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        color: #000000d9;</span><br><span class="line">        border: 1px solid rgba(0, 0, 0, 0.1); /* 添加边框 */</span><br><span class="line">        padding: 8px 16px;</span><br><span class="line">        line-height: 1.5715;</span><br><span class="line">        width: 280px;</span><br><span class="line">        z-index: 9999;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .title &#123;</span><br><span class="line">        font-weight: 500;</span><br><span class="line">        margin-bottom: 4px;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        line-height: 24px;</span><br><span class="line">        text-align: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .content &#123;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        margin-bottom: 20px;</span><br><span class="line">        text-align: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .actions &#123;</span><br><span class="line">        margin-top: 4px;</span><br><span class="line">        text-align: right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .actions a &#123;</span><br><span class="line">        padding: 3px 8px;</span><br><span class="line">        line-height: 1;</span><br><span class="line">        transition: background-color 0.2s linear;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .actions a:hover &#123;</span><br><span class="line">        background-color: rgba(64, 87, 109, 0.1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .actions .web-update-notice-refresh-btn &#123;</span><br><span class="line">        color: rgba(0, 0, 0, 0.25);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .update-modal .actions .web-update-notice-dismiss-btn &#123;</span><br><span class="line">        margin-left: 8px;</span><br><span class="line">        color: #1677ff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>当轮询触发更新操作时，展示弹框。</p>
<p>当id⼀致时，继续进行轮询操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722924049477.png" alt="1722924049477"></p>
<h4 id="继自实现方法的结构优化"><a href="#继自实现方法的结构优化" class="headerlink" title="继自实现方法的结构优化"></a>继自实现方法的结构优化</h4><p><code>index.html </code>替换掉原来的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">__client__version__</span> = <span class="string">&#x27;&lt;%= process.env.VUE_APP_SITE_VERSION %&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> _cookieKey = <span class="string">&#x27;accept_cookie_20211130&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>updateCheck.js </code>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UpdateModal</span> <span class="keyword">from</span> <span class="string">&#x27;./updateModal.vue&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 设置定时器，每隔10分钟查询⼀次最新的 commit ID</span></span><br><span class="line">    <span class="built_in">setInterval</span>(fetchLatestCommitId, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchLatestCommitId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/v.txt&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">newCommitId</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> currentCommitId = <span class="variable language_">window</span>.<span class="property">__client__version__</span></span><br><span class="line">        <span class="keyword">if</span> (currentCommitId &amp;&amp; newCommitId &amp;&amp; currentCommitId !== newCommitId) &#123;</span><br><span class="line">            <span class="comment">// 提⽰更新</span></span><br><span class="line">            <span class="title function_">showUpdateModal</span>(newCommitId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showUpdateModal</span>(<span class="params">newCommitId</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">UpdateModalComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">UpdateModal</span>)</span><br><span class="line">    <span class="keyword">const</span> updateModalInstance = <span class="keyword">new</span> <span class="title class_">UpdateModalComponent</span>(&#123;</span><br><span class="line">        <span class="attr">propsData</span>: &#123; newCommitId &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.$destroy()</span><br><span class="line">                div.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(div)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">refresh</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    updateModalInstance.$mount(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还原 <code>package.json</code> 的修改，新增 <code>vue.config.js</code> 相关代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取当前Git仓库的短提交哈希，将其存储在cmtId变量中</span></span><br><span class="line"><span class="keyword">const</span> cmtId = <span class="title function_">execSync</span>(<span class="string">&#x27;git rev-parse --short HEAD&#x27;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>()</span><br><span class="line"><span class="comment">// 将cmtId写⼊到public⽬录下的v.txt⽂件中</span></span><br><span class="line"><span class="keyword">const</span> versionFile = path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;public&#x27;</span>, <span class="string">&#x27;v.txt&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(versionFile, cmtId)</span><br><span class="line">process.<span class="property">env</span>.<span class="property">VUE_APP_SITE_VERSION</span> = cmtId</span><br></pre></td></tr></table></figure>

<h4 id="方案缺陷-1"><a href="#方案缺陷-1" class="headerlink" title="方案缺陷"></a>方案缺陷</h4><ul>
<li>**使用第三方组件缺乏定制化:**可能无法完全满足定制化需求，或者与应用现有的架构和代码库不兼容。</li>
<li>**第三方组件生态问题:**基于较小团队开发，质量不稳定，缺乏完整的文档</li>
<li>**无法实时推送更新:**轮询方式可能导致更新提示的延迟，用户可能需要等待一段时间才能收到更新提示，而且并不能保证实时性。</li>
<li>**网络请求频繁:**每次轮询都需要进行网络请求来获取最新的commit id，即使 commit id没有发生变化。这会增加网络流量和服务器负担。</li>
</ul>
<h3 id="方案三-使用-Service-Worker拦截页面的网络请求"><a href="#方案三-使用-Service-Worker拦截页面的网络请求" class="headerlink" title="方案三 使用 Service Worker拦截页面的网络请求"></a>方案三 使用 <code>Service Worker</code>拦截页面的网络请求</h3><p><code>Service worker</code> 是一项浏览器技术，它可以在浏览器后台运行，拦截和处理网络请求。通过<code>Service Worker</code>，网站可以实现离线缓存、网络请求代理、推送通知等功能，提高用户体验和网站性能。<code>Service worker</code>是一个浏览器中的进程而不是浏览器内核下的线程，因此它在被注册安装之后能够被在多个页面中使用，也不会因为页面的关闭而被销毁。因此，<code>Service Worker</code> 很适合被用与多个页面需要使用的复杂数据的计算——购买一次，全家“收益”。</p>
<h4 id="基于-cli-plugin-pwa-插件的实现思路"><a href="#基于-cli-plugin-pwa-插件的实现思路" class="headerlink" title="基于 cli-plugin-pwa 插件的实现思路"></a>基于 <code>cli-plugin-pwa</code> 插件的实现思路</h4><h5 id="引入cli-plugin-pwa"><a href="#引入cli-plugin-pwa" class="headerlink" title="引入cli-plugin-pwa"></a>引入<code>cli-plugin-pwa</code></h5><blockquote>
<p><a href="https://github.com/vite-pwa/vite-plugin-pwa">https://github.com/vite-pwa/vite-plugin-pwa</a></p>
</blockquote>
<h5 id="在-src-registerServiceWorker-js-添加事件触发"><a href="#在-src-registerServiceWorker-js-添加事件触发" class="headerlink" title="在 src/registerServiceWorker.js 添加事件触发"></a>在 <code>src/registerServiceWorker.js</code> 添加事件触发</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable no-console */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; register &#125; <span class="keyword">from</span> <span class="string">&quot;register-service-worker&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> &amp;&amp; navigator.<span class="property">serviceWorker</span>) &#123;</span><br><span class="line">    <span class="title function_">register</span>(<span class="string">`<span class="subst">$&#123;process.env.BASE_URL&#125;</span>service-worker.js`</span>, &#123;</span><br><span class="line">        <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">                <span class="string">&quot;App is being served from cache by a service worker.\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;For more details, visit https://goo.gl/AFskqB&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="title function_">registered</span>(<span class="params">registration</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Service worker has been registered.&quot;</span>);</span><br><span class="line">            <span class="comment">// 通过测试新的服务⼯作线程来定期检查应⽤更新</span></span><br><span class="line">            <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                registration.<span class="title function_">update</span>();</span><br><span class="line">            &#125;, <span class="number">1000</span>); <span class="comment">// 这⾥为了测试 每秒检查⼀次</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">cached</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Content has been cached for offline use.&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">updatefound</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;New content is downloading.&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 有个更新 通知⻚⾯更新</span></span><br><span class="line">        <span class="title function_">updated</span>(<span class="params">registration</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;New content is available; please refresh.&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建⼀个⾃定义事件</span></span><br><span class="line">            <span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&quot;swupdatefound&quot;</span>, &#123; <span class="attr">detail</span>: registration &#125;);</span><br><span class="line">            <span class="comment">// 触发这个事件</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">offline</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">                <span class="string">&quot;No internet connection found. App is running in offline mode.&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">error</span>(<span class="params">error</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error during service worker registration:&quot;</span>, error);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> refreshing;</span><br><span class="line">    <span class="comment">// 监听需要更新事件 调⽤ window.location.reload()</span></span><br><span class="line">    navigator.<span class="property">serviceWorker</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;controllerchange&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (refreshing) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line"></span><br><span class="line">        refreshing = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在页面中添加事件监听"><a href="#在页面中添加事件监听" class="headerlink" title="在页面中添加事件监听"></a>在页面中添加事件监听</h5><p>在 <code>main.js</code> 或 <code>store</code> 中添加事件监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加对应⾃定义事件的监听</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;swupdatefound&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 提⽰⽤⼾刷新</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">confirm</span>(<span class="string">&quot;新内容可⽤,请刷新&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">// e.detail == registration</span></span><br><span class="line">        <span class="comment">// waiting.postMessage(&#123; type: &quot;SKIP_WAITING&quot; &#125;) 是固定写法</span></span><br><span class="line">        <span class="comment">// ⽤于触发更新 navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;..</span></span><br><span class="line">        e.<span class="property">detail</span>.<span class="property">waiting</span>.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;SKIP_WAITING&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>离线支持:</strong> <code>Service Worker</code> 可以缓存页面资源，使得即使在离线状态下用户仍然可以访问应用，因此即使用户在没有网络连接的情况下打开页面，也能收到更新提示。</li>
<li>**即时更新提示:**当检测到新版本可用时，<code>Service Worker</code>可以立即向客户端发送更新提示，而无需等待客户端发起请求，从而能够及时通知用户有新版本可用。</li>
</ul>
<h4 id="方案缺陷-2"><a href="#方案缺陷-2" class="headerlink" title="方案缺陷"></a>方案缺陷</h4><ul>
<li>**兼容性问题:**出于对安全问题的考虑，Service Worker只能被使用在 <code>https </code>或者本地的<code>localhost </code>环境下。</li>
<li>**具有一定的理解和使用难度:**如果不正确地配置缓存策略，可能会导致 <code>Service Worker</code>无法正确地获取最新的资源，从而导致更新提示失败。</li>
<li>**资源占用问题:**接入 <code>service worker</code> 需要成本，本地运行一个 <code>worker</code> 也会占用内存和<code>cpu</code>资源。</li>
</ul>
<h3 id="方案四-基于WebSocket建立长期运行的连接"><a href="#方案四-基于WebSocket建立长期运行的连接" class="headerlink" title="方案四 基于WebSocket建立长期运行的连接"></a>方案四 基于<code>WebSocket</code>建立长期运行的连接</h3><p><code>Websocket</code>是一种协议，用于在 <code>Web</code> 应用程序中创建实时、双向的通信通道。<code>WebSocket</code>可以在浏览器和服务器之间建立一条双向通信的通道，实现服务器主动向浏览器推送消息，而无需浏览器向服务器不断发送请求。其原理是在浏览器和服务器之间建立一个“套接字”，通过“握手”的方式进行数据传输。由于该协议需要浏览器和服务器都支持，因此需要在应用程序中对其进行判断和处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/ImgPicGo/img/1722924701316.png" alt="1722924701316"></p>
<h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>建立 <code>WebSocket</code> 连接:在客户端，使用 <code>webSocket API</code> 建立与服务器的 <code>Websocket</code> 连接。当连接建立成功后，客户端将可以接收服务器发送的实时消息。</li>
<li>服务器推送消息: 当服务器检测到新版本可用时，向与客户端建立的 <code>webSocket</code> 连接发送更新提示消息。消息内容可以包括版本号、更新说明等信息。</li>
<li>客户端接收消息: 客户端通过监听 <code>webSocket </code>连接的消息事件，实时接收服务器发送的更新提示消息。</li>
<li>解析消息并提示用户: 客户端收到更新提示消息后，解析消息内容，并向用户显示更新提示。可以通过弹窗、通知栏等方式向用户提示有新版本可用，并提供刷新页面的选项。</li>
<li>用户操作:用户收到更新提示后，可以选择立即刷新页面以获取新版本，或者选择稍后刷新。</li>
<li>刷新页面: 如果用户选择立即刷新页面，客户端通过 <code>JavaScript</code> 脚本触发页面的刷新操作，使页面重新加载并获取最新版本的内容。</li>
<li>错误处理: 在实现过程中，需要考虑到网络连接中断、消息丢失等异常情况的处理，以确保系统的稳定性和可靠性。</li>
</ol>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>实时性:</strong> <code>WebSocket</code> 提供了双向实时通信的能力，可以立即将更新提示推送到客户端，使用户能够及时得知新版本的可用性，提高用户体验。</li>
<li><strong>高效性:</strong> <code>webSocket</code> 是基于 TCP 连接的，相比传统的 HTTP 请求，<code>WebSocket</code> 的通信开销更小，消息传输更高效，可以快速地将更新提示发送到客户端。</li>
</ul>
<h4 id="方案缺陷-3"><a href="#方案缺陷-3" class="headerlink" title="方案缺陷"></a>方案缺陷</h4><ul>
<li><strong>需要后端配合</strong></li>
<li>**服务器负担:**使用 <code>webSocket</code>进行实时通信会增加服务器的负担，特别是在用户量较大的情况下，可能会导致服务器压力过大。</li>
</ul>
<h2 id="方案比较-选择"><a href="#方案比较-选择" class="headerlink" title="方案比较&amp;选择"></a>方案比较&amp;选择</h2><p><em><strong>方案一&amp;方案二：</strong></em>方案二较之方案一，轮询加载<code>latest_commit_id.txt</code>比加载 <code>index.html</code>对服务器的压力更小，但都存在无法实时推送更新的问题</p>
<p><strong>方案三：</strong>虽然能解决无法及时实时推送更新的问题，但是会造成更大的资源占用，且使用和配置具有一定难度和复杂性，可能会引起其他缓存相关的问题<br><strong>方案四：</strong>需要一个<code>websocket</code>服务，且需要后端配合</p>
<p>考虑到平台的版本更新不会发生的很频繁且可以通过减少轮询周期来优化无法实时推送更新的问题，故<strong>综合考虑之下选择方案二</strong></p>
]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络考纲复习笔记</title>
    <url>/2023/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%BA%B2%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络考纲复习"><a href="#计算机网络考纲复习" class="headerlink" title="计算机网络考纲复习"></a>计算机网络考纲复习</h1><h2 id="第一章-计算机网络和英特网："><a href="#第一章-计算机网络和英特网：" class="headerlink" title="第一章 计算机网络和英特网："></a>第一章 <strong>计算机网络和英特网</strong>：</h2><h3 id="计算机网络的定义："><a href="#计算机网络的定义：" class="headerlink" title="计算机网络的定义："></a>计算机网络的定义：</h3><p>两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。</p>
<h3 id="协议的定义和基本要素："><a href="#协议的定义和基本要素：" class="headerlink" title="协议的定义和基本要素："></a>协议的定义和基本要素：</h3><p>定义了两个或多个通信实体间所交换报文的格式和次序，以及在报文发送和&#x2F;或接收或者其他事件方面所采取的行动（响应）。</p>
<p>基本要素：</p>
<ul>
<li>语法：报文格式</li>
<li>语义：各字段的含义</li>
<li>同步(时序)：报文传输的先后顺序</li>
</ul>
<h3 id="Internet的构成描述："><a href="#Internet的构成描述：" class="headerlink" title="Internet的构成描述："></a>Internet的构成描述：</h3><p><strong>具体构成：</strong></p>
<p>硬件上：</p>
<p>数以亿计的计算互连设备、通信链路(link)、分组(packet)交换。</p>
<p>服务上：</p>
<p>提供网络应用基础架构、为分布式应用程序提供通信服务接口（无连接服务和面向连接服务）。</p>
<p><strong>网络交换方式：</strong></p>
<p><strong>电路交换</strong></p>
<p>多路复用（Multiple Access）</p>
<p>分片分配到会话</p>
<p>分片没有被会话使用的情况下，分片空载(不共享)</p>
<p>电路级性能（有保证）要求呼叫建立－－建立一个专门的端到端线路(意味着每个链路上预留一个线路)</p>
<p>（1）预先建立连接，预留资源，发送方以恒定速度发送数据</p>
<p>（2）电路和通信链路的区别</p>
<p>（3）链路带宽和一条电路的传输速率的关系</p>
<p>（4）频分多路复用和时分多路复用（会计算）</p>
<p>（5）电路交换的优缺点：电路级的性能，时延小；效率低；创建连接过程复杂</p>
<p>设文件长640kb，链路采用时隙数为24的TDM，传输速率1.536Mb&#x2F;s，主机之间创建一条端到端电路需500ms。</p>
<blockquote>
<p>每条电路的传输速率：(1.536Mb&#x2F;s) &#x2F;24&#x3D;64kb&#x2F;s</p>
<p>传输文件时间：640kb&#x2F;(64kb&#x2F;s)&#x3D;10s</p>
<p>A到B的总发送时间：10s+0.5s&#x3D;10.5s</p>
</blockquote>
<p><strong>分组交换</strong></p>
<p>（1）报文：应用程序要传输的信息，包含控制或数据</p>
<p>（2）分组：报文拆分成若干的数据块，每个数据块加上头部信息，构成分组</p>
<p>（3）特点：所有分组共享网络资源、每个分组使用全部链路带宽、资源按需使用；</p>
<p>优点：适合大量的突发数据传输，资源共享、简单, 不需要建立连接</p>
<p>缺点：过渡竞争导致分组延迟与丢失，需要可靠数据传输、拥塞控制协议</p>
<p>分组交换网络分类：</p>
<p><strong>数据报网络:</strong> </p>
<p>TCP&#x2F;IP分组目的地址决定下一跳</p>
<p>会话期间路由可以改变</p>
<p>比方: 驱车逐段问路  </p>
<p><strong>虚电路网络: X.25,FR,ATM</strong></p>
<p>每个分组有1个标签  (虚电路号,virtual circuit ID), 标签决定下1跳</p>
<p>连接建立时确定固定的路径, 并且将保持于整个会话期间</p>
<p>路由器必须为每个连接维护状态信息</p>
<p><strong>企业（和家庭）接入网络 ：</strong></p>
<p>（1）LAN（ Ethernet 技术）</p>
<p>（2）WIFI（无线局域网技术，802.11）</p>
<h3 id="分组延迟的4种类型"><a href="#分组延迟的4种类型" class="headerlink" title="分组延迟的4种类型"></a>分组延迟的4种类型</h3><p>（1）节点处理时延：差错检测、选择输出链路，微秒级</p>
<p>（2）排队时延：等待被发送到输出链路上的时间，取决于路由器的拥塞程度</p>
<p>（3）传输时延：R&#x3D;链路带宽 (bps)，L&#x3D;分组长度 (bits)，发送分组比特流的时间 &#x3D; L&#x2F;R</p>
<p>（4）传播时延：d &#x3D; 物理链路的长度，s &#x3D; 介质的信号传播速度，传播延迟 &#x3D; d&#x2F;s</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/127b020fc491777f63e6c814fa4fdff7.png" alt="img"></p>
<p>排队时延：流量强度(traffic intensity) &#x3D; La&#x2F;R，其中a为平均分组到达速率， L为分组长度， R为链路带宽</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/71fe4aae1488f9745085b1398c21512f.png" alt="img"></p>
<ul>
<li>La&#x2F;R ~ 0: 分组稀疏到达,无队列,平均排队延迟极小接近于0</li>
<li>La&#x2F;R -&gt; 1: 分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大</li>
<li>La&#x2F;R &gt; 1: 输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大</li>
</ul>
<h3 id="TCP-IP分层模型："><a href="#TCP-IP分层模型：" class="headerlink" title="TCP&#x2F;IP分层模型："></a>TCP&#x2F;IP分层模型：</h3><p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230626234631.png" alt="QQ图片20230626234631"></p>
<table>
<thead>
<tr>
<th>TCP&#x2F;IP 各层</th>
<th>PDU名称</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>APDU</td>
</tr>
<tr>
<td>运输层</td>
<td>段</td>
</tr>
<tr>
<td>网络层</td>
<td>分组</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流</td>
</tr>
</tbody></table>
<p>应用层application: 支持网络应用，<strong>报文</strong>传送FTP, SMTP, STTP …</p>
<p>传输层transport: 主机进程间<strong>报文段</strong>传送，TCP, UDP</p>
<p>网络层network: 主机(源目标节点)间分组（<strong>数据报</strong>）传送主要是IP协议, 路由协议</p>
<p>链路层link: 相邻网络节点间的数据<strong>帧</strong>传送，PPP, Ethernet …</p>
<p>物理层physical: 物理介质上的<strong>比特</strong>传送</p>
<h3 id="常见的网络攻击："><a href="#常见的网络攻击：" class="headerlink" title="常见的网络攻击："></a>常见的网络攻击：</h3><p>被动攻击和主动攻击(篡改、伪造消息)</p>
<p>（1）植入恶意软件（病毒、蠕虫、僵尸网络）:自我复制</p>
<p>（2）DoS攻击（弱点攻击【向目标主机上易受攻击的应用程序和操作系统发送精细的报文】、带宽洪泛【向目标主机发送大量分组】、连接洪泛【利用目标主机创建半开或全开的TCP连接】）</p>
<p>（3）嗅探分组（无线网络和以太网LAN）：数据加密</p>
<p>（4）伪装（IP哄骗）：采用端点鉴别机制</p>
<p>（5）中间人攻击（攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据；虚拟专用网(VPN)、SSL证书）</p>
<h2 id="第二章-应用层："><a href="#第二章-应用层：" class="headerlink" title="第二章  应用层："></a>第二章  <strong>应用层</strong>：</h2><h3 id="Web应用和HTTP协议："><a href="#Web应用和HTTP协议：" class="headerlink" title="Web应用和HTTP协议："></a>Web应用和HTTP协议：</h3><h4 id="基本术语（网页、URL等）、"><a href="#基本术语（网页、URL等）、" class="headerlink" title="基本术语（网页、URL等）、"></a>基本术语（网页、URL等）、</h4><p>网页（Web页，或称文档）由许多对象组成。 </p>
<p>对象就是文件，可以是HTML文件, JPEG图像, Java applet, 音频文件…</p>
<p>多数网页由单个基本HTML文件和若干个所引用的对象构成</p>
<p>每个对象被一个URL(Uniform Resource Locator统一资源定位符)寻址</p>
<p><strong>HTTP</strong>: 超文本传输协议（HyperText Transfer Protocol）</p>
<p>Web的应用层协议</p>
<p><strong>client&#x2F;server模式</strong></p>
<p>client: 浏览器browser请求, 接收, “解释显示” Web对象</p>
<p>server: Web服务器响应请求,发送 Web对象</p>
<h4 id="HTTP的特性及其区别-无状态、非持久和持久等）"><a href="#HTTP的特性及其区别-无状态、非持久和持久等）" class="headerlink" title="HTTP的特性及其区别(无状态、非持久和持久等）"></a>HTTP的特性及其区别(无状态、非持久和持久等）</h4><p><strong>特性：</strong>HTTP是一个无状态的协议：HTTP服务器不维护客户先前的状态信息</p>
<p><strong>非持久HTTP连接</strong>：每个TCP连接上只传送一个对象，下载多个对象需要建立多个TCP连接，HTTP&#x2F;1.0使用非持久HTTP连接</p>
<p><strong>持久HTTP连接</strong>：一个TCP连接上可以传送多个对象，HTTP&#x2F;1.1默认使用持久HTTP连接</p>
<p>例：假设该页面含有一个HTML基本文件和10个JPEG图形， 并且这11个对象位于同一台服务器上。</p>
<p>进一步假设该HTML文件的URL为：<a href="http://www.someschool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p>
<p>(1) HTTP客户进程在端口号80发起一个到服务器 <a href="http://www.someschool.edu/">www.someSchool.edu</a> 的TCP连接，该端口号是HTTP的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。</p>
<p>(2) HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。请求报文中包含了路径名&#x2F;someDepartment&#x2F;home.index。</p>
<p>(3) HTTP服务器进程经它的套接字接收该请求报文，从其存储器(RAM或磁盘)中检索出对象 <a href="http://www.someschool.edu/someDepartment/home.index">www.someSchool.edu/someDepartment/home.index</a> ，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。</p>
<p>(4)HTTP服务器进程通知TCP断开该TCP连接。</p>
<p>(5)HTTP客户接收响应报文，TCP连接关闭。该报文指出封装的对象件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的引用。</p>
<p>(6) 对每个引用的JPEG图形对象重复前4个步骤。</p>
<h4 id="COOKIE技术"><a href="#COOKIE技术" class="headerlink" title="COOKIE技术"></a>COOKIE技术</h4><p> Cookies作用，如何实现</p>
<p>（1）Cookies: 跟踪用户，提高用户和服务器的交互性</p>
<p>（2）cookie头部行在HTTP请求消息（或响应消息）中</p>
<p>（3）cookie文件 保存在<strong>用户主机</strong>中并被<strong>用户浏览器</strong>管理</p>
<p>（4）cookie也保存在Web站点的<strong>后端数据库</strong></p>
<p>（5）应用场景：身份认证&#x2F;虚拟购物车&#x2F;推荐广告&#x2F;用户会话状态</p>
<p>（6）优点：cookies允许网站更加了解你，你可以提供名字和e-mail给网站 ，广告公司通过网站获得信息，Cookies不适合游动用户</p>
<h4 id="Web缓存的作用、实现基本原理"><a href="#Web缓存的作用、实现基本原理" class="headerlink" title="Web缓存的作用、实现基本原理"></a>Web缓存的作用、实现基本原理</h4><p><strong>Web缓存目标</strong>:在不访问服务器的前提下满足客户端的HTTP请求</p>
<h3 id="实现基本原理："><a href="#实现基本原理：" class="headerlink" title="实现基本原理："></a>实现基本原理：</h3><ul>
<li>用户设定浏览器通过缓存进行Web访问</li>
<li>浏览器向缓存&#x2F;代理服务器发送所有的HTTP请求<ul>
<li>如果所请求对象在缓存中，缓存器返回对象</li>
<li>否则缓存器向起始服务器发出请求，接收对象后转发给客户机</li>
</ul>
</li>
<li>缓存既充当客户端，也充当服务器</li>
</ul>
<h3 id="电子邮件：组成及其使用的协议"><a href="#电子邮件：组成及其使用的协议" class="headerlink" title="电子邮件：组成及其使用的协议"></a>电子邮件：组成及其使用的协议</h3><p><strong>组成：</strong></p>
<p>用户代理user agents     邮件服务器mail servers    简单邮件传送协议和邮件接收协议</p>
<p>使用的协议：<strong>SMTP</strong></p>
<ul>
<li>客户使用TCP来可靠传输邮件消息到服务器端口号<strong>25</strong></li>
<li>传输的3个阶段：握手 (问候)、邮件消息的传输、结束</li>
<li>发送服务器到接收服务器采用直接传送</li>
<li>使用持久连接</li>
<li>命令&#x2F;应答的交互，服务器使用 CRLF.CRLF 来判断邮件消息的结束<ul>
<li>命令: ASCII文本格式</li>
<li>应答: 状态码及其短语</li>
</ul>
</li>
<li>邮件消息必须是7-bit ASCII</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/ddbee45e35914c5bb66b840f13299c78.png" alt="img"></p>
<h3 id="DNS的功能、实现和查询方式"><a href="#DNS的功能、实现和查询方式" class="headerlink" title="DNS的功能、实现和查询方式"></a>DNS的功能、实现和查询方式</h3><p><strong>功能：</strong></p>
<ul>
<li>主机名到IP地址的转换</li>
<li>主机别名：一个主机可以有一个规范主机名和多个主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配<ul>
<li>DNS实现冗余服务器：一个IP地址集合可以对应于同一个规范主机名。</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>分布式数据库：一个由分层DNS服务器实现的分布式数据库</li>
<li>应用层协议：DNS服务器实现域名转换 (域名&#x2F;地址转换)</li>
</ul>
<p><strong>查询方式：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/b92e326edb260c56dc94dce8b2c71cfd.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/b20fa32ed757b5bf44167293f894e2d3.png" alt="img"></p>
<h3 id="内容分发网络-CDN-要解决的基本问题和实现的简单原理"><a href="#内容分发网络-CDN-要解决的基本问题和实现的简单原理" class="headerlink" title="内容分发网络(CDN)要解决的基本问题和实现的简单原理"></a>内容分发网络(CDN)要解决的基本问题和实现的简单原理</h3><p>挑战: 如何从海量的视频中，挑选出某些内容，采用流的方式发送给成千上万的用户？</p>
<p>CDN: 将内容的拷贝存储在CDN节点中 用户向CDN请求内容被定向到附近的拷贝，取得内容如果网络路径拥塞，则可能选择其他的拷贝</p>
<h2 id="第三章-运输层："><a href="#第三章-运输层：" class="headerlink" title="第三章 运输层："></a>第三章 <strong>运输层</strong>：</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><strong>UDP 是面向报文的</strong></p>
<p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。即<strong>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</strong>。</p>
<p><strong>基于Internet IP协议</strong></p>
<ul>
<li>复用&#x2F;分用</li>
<li>简单的错误校验</li>
</ul>
<p><strong>“尽最大努力”服务，报文段可能</strong>:</p>
<ul>
<li>丢失</li>
<li>会传递失序的报文到应用程序无连接</li>
<li>在UDP接收者发送者之间<strong>没有握手</strong></li>
<li>每个UDP 报文段的处理独立于其他报文段</li>
</ul>
<p><strong>无连接:</strong></p>
<ul>
<li>在UDP接收者发送者之间没有握手</li>
<li>每个UDP 数据段的处理独立于其他数据段</li>
</ul>
<p><strong>为什么有 UDP?</strong></p>
<ul>
<li>不需要建立连接 (减少延迟)</li>
<li>简单: 在发送者接受者之间不需要连接状态</li>
<li>很小的报文段首部</li>
<li>没有拥塞控制: UDP 能够用尽可能快的速度传递</li>
</ul>
<p><strong>常用于流式多媒体应用：丢包容忍&#x2F;速率敏感</strong></p>
<p>其他UDP应用：DNS&#x2F;SNMP&#x2F;RTP</p>
<p><strong>经UDP的可靠传输</strong> : 在应用层增加可靠性&#x2F;应用程序特定的差错恢复！</p>
<h3 id="可靠数据传输原理：掌握可靠数据传输的基本原理和使用的主要技术。GBN和SR两种可靠传输技术的特点和原理。"><a href="#可靠数据传输原理：掌握可靠数据传输的基本原理和使用的主要技术。GBN和SR两种可靠传输技术的特点和原理。" class="headerlink" title="可靠数据传输原理：掌握可靠数据传输的基本原理和使用的主要技术。GBN和SR两种可靠传输技术的特点和原理。"></a>可靠数据传输原理：掌握可靠数据传输的基本原理和使用的主要技术。GBN和SR两种可靠传输技术的特点和原理。</h3><h4 id="可靠数据传输的基本原理："><a href="#可靠数据传输的基本原理：" class="headerlink" title="可靠数据传输的基本原理："></a>可靠数据传输的基本原理：</h4><p>Rdt1.0: 完全可靠信道上的可靠数据传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/6dbb3bc2c0e34aea3d0eb1b3418e1164.png" alt="img"></p>
<p>Rdt2.0: 具有bit错误的信道</p>
<ul>
<li>下层信道可能让传输分组中的bit受损：利用校验和检测bit位错误</li>
<li>问题: 如何从错误中恢复<ul>
<li>确认(ACKs): 接收方明确告诉发送方分组接收正确</li>
<li>否认 (NAKs):接收方明确告诉发送方分组接收出错</li>
<li>发送方收到NAK后重发这个分组</li>
</ul>
</li>
<li>在 rdt2.0中的新机制 (在 rdt1.0中没有的)：<ul>
<li>差错检测</li>
<li>接收方反馈: 控制信息 (ACK,NAK) rcvr-&gt;sender</li>
<li>重传</li>
</ul>
</li>
</ul>
<p>停等协议:发送方发送一个报文，然后等待接受方的响应</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/d6e58f65494edb95f86e37ddc80a7e25.png" alt="img"></p>
<p><strong>rdt2.0: 缺陷</strong></p>
<p>如果ACK&#x2F;NAK发生错误&#x2F;被破坏(corrupted)会怎么样？</p>
<ul>
<li>为ACK&#x2F;NAK增加校验和，检错并纠错</li>
<li>发送方收到被破坏ACK&#x2F;NAK时不知道接收方发生了什么，添加额外的控制消息</li>
<li>如果ACK&#x2F;NAK坏掉，发送方重传</li>
<li>不能简单的重传：产生重复分组</li>
</ul>
<p>如何解决重复分组问题？</p>
<ul>
<li>序列号(Sequence number): 发送方给每个分组增加序列号</li>
<li>接收方丢弃重复分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/c2e5401e8026bf787cf525a7069b93a8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/7a2de9807bfc8aae1a69a0d5fdadf227.png" alt="img"></p>
<p><strong>rdt2.2: 无NAK的消息协议</strong></p>
<p>我们真的需要两种确认消息(ACK + NAK)吗？</p>
<ul>
<li>同 rdt2.1一样的功能, 但只用 ACKs</li>
<li>如何实现？<ul>
<li>接收方通过ACK告知最后一个被正确接收的分组</li>
<li>在ACK消息中显式地加入被确认分组的序列号</li>
</ul>
</li>
<li>发送方收到重复ACK之后，采取与收到NAK消息相同的动作<ul>
<li>重传当前分组</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/e02d542b01d71179304adf11dac79695.png" alt="img"></p>
<p><strong>rdt3.0: 具有出错和丢失的信道</strong></p>
<p>新假设: 下层信道还要丢失报文 (数据或者 ACKs)</p>
<p>校验和, 序号, 确认, 重发将会有帮助，但是不够</p>
<p>方法: 发送者等待“合理的”确认时间</p>
<ul>
<li>如果在这个时间内没有收到确认就<strong>重发</strong></li>
<li>如果报文（或者确认）只是延迟 (没有丢失):<ul>
<li>重发将导致重复，但是使用序号已经处理了这个问题</li>
<li>接受方必须指定被确认的报文序号</li>
</ul>
</li>
<li>要求<strong>倒计时定时器</strong>：只有在定时器超时时才触发重发</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/938e9c19726bad848f71ca05fab778bf.png" alt="img"></p>
<p><strong>rdt3.0的性能分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/8bbb45dbe05b1c738a9aa52800ab625b.png" alt="img"></p>
<h4 id="GBN协议"><a href="#GBN协议" class="headerlink" title="GBN协议:"></a>GBN协议:</h4><p><strong>Go-Back-N(GBN)协议: 发送方</strong></p>
<ul>
<li>分组头部包含k-bit序列号</li>
<li>窗口尺寸为N，最多允许N个分组未确认</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/332bbc9b085622fa656098f61c92c3ff.png" alt="img"></p>
<ul>
<li>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收<ul>
<li>可能收到重复ACK</li>
</ul>
</li>
<li>对第一个发送未被确认的报文定时(timer)</li>
<li>timeout(n):若超时，重传窗口中的分组n及所有更高序号的分组</li>
</ul>
<p><em>Go-Back-N(GBN)协议: 接收方</em>*</p>
<p>只有ACK: 对接收的分组总是发送具有最高按序序号的ACK</p>
<ul>
<li>可能产生冗余的ACKs</li>
<li>仅仅需要记住期望的序号值（expectedseqnum）</li>
</ul>
<p>对失序的分组:</p>
<ul>
<li>丢弃 (不缓存) -&gt; <strong>没有接收缓冲区</strong>!</li>
<li>重新确认具有按序的分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/93bb0694600038f51ec65481b6af85b2.png" alt="img"></p>
<h4 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议:"></a>SR协议:</h4><ul>
<li><p>接收方分别确认已经收到的分组:必要时，缓冲报文, 最后按序提交给上层</p>
</li>
<li><p>发送者只重发没有收到确认的分组:对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)</p>
</li>
<li><p>发送窗口:N 个连续序号&#x2F;限制被发送的未确认的分组数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/5ff6d82f4c2d80c2217be99db010e904.png" alt="img"></p>
</li>
</ul>
<p><strong>发送方</strong></p>
<ul>
<li>从上层收到数据 ：如果下一个可用的序号在发送方窗口内，则将数据打包并发送,启动定时器</li>
<li>超时(n)：重发分组n, 重启定时器</li>
<li>收到ACK(n)在[sendbase,sendbase+N-1]内:<ul>
<li>标记分组n被接收</li>
<li>如果n是最小的未确认分组，则增加窗口基序号到下一个未被确认的序号</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong></p>
<ul>
<li>分组n的序号在[rcvbase, rcvbase+N-1]内<ul>
<li>发送ACK(n)</li>
<li>失序分组: 缓冲</li>
<li>有序分组: 交付上层 (包括已经缓冲的有序分组), 提高窗口到下一个没有接收的分组</li>
</ul>
</li>
<li>分组n在[rcvbase-N,rcvbase-1]内<ul>
<li>发送ACK(n)</li>
</ul>
</li>
<li>其他：忽略</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/d3b6a73083e9b97504184499d7e65ac6.png" alt="img"></p>
<h3 id="TCP协议及TCP可靠数据传输原理"><a href="#TCP协议及TCP可靠数据传输原理" class="headerlink" title="TCP协议及TCP可靠数据传输原理"></a>TCP协议及TCP可靠数据传输原理</h3><p>TCP是面向面向连接传输</p>
<p><strong>TCP是面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<p><strong>有可能将多条数据当成一条数据进行处理</strong>，因此需要在应用层进行数据的边界管理</p>
<ul>
<li>点到点:<ul>
<li>一个发送者,一个接收者</li>
</ul>
</li>
<li>可靠按序的字节流:<ul>
<li>没有“信息边界”</li>
</ul>
</li>
<li>流水线:<ul>
<li>TCP 拥塞和流量控制设置窗口大小</li>
</ul>
</li>
<li>收发缓冲区</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/12747eda42e9612ec3b93a2449b1b389.png" alt="img"></p>
<ul>
<li>全双工数据:<ul>
<li>同一个连接上的双向数据流</li>
<li>MSS: 最大报文段长</li>
</ul>
</li>
<li>面向连接:<ul>
<li>在数据交换前握手(交换控制信息)</li>
<li>连接状态只在连接的两端中维护，在沿途节点中并不维护状态。</li>
<li>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</li>
</ul>
</li>
<li>流量控制:<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<h3 id="掌握TCP拥塞控制方法"><a href="#掌握TCP拥塞控制方法" class="headerlink" title="掌握TCP拥塞控制方法"></a>掌握TCP拥塞控制方法</h3><p>TCP连接的接收方有一个接收缓冲区:</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/image-20230627002735633.png" alt="image-20230627002735633"></p>
<p><strong>速度匹配服务</strong>：发送速率和接收应用程序的提取速率匹配</p>
<p><strong>流量控制</strong>：发送方不能发送的太多太快，让接收缓冲区溢出</p>
<p>应用程序可能从这个缓冲区读出数据很慢</p>
<p>(假设 TCP 接收方丢弃失序的报文段)</p>
<ul>
<li>缓冲区的剩余空间&#x3D; RcvWindow&#x3D; RcvBuffer-[LastByteRcvd - LastByteRead]</li>
<li>接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间</li>
<li>Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</li>
<li>Receiver告知Sender，RcvWindow&#x3D;0,会出现什么情况？</li>
</ul>
<h2 id="第四章-网络层："><a href="#第四章-网络层：" class="headerlink" title="第四章 网络层："></a>第四章 <strong>网络层</strong>：</h2><h3 id="网络层提供的服务和功能：转发和路由。网络层数据平面和控制平面各自完成的功能。"><a href="#网络层提供的服务和功能：转发和路由。网络层数据平面和控制平面各自完成的功能。" class="headerlink" title="网络层提供的服务和功能：转发和路由。网络层数据平面和控制平面各自完成的功能。"></a>网络层提供的服务和功能：转发和路由。网络层数据平面和控制平面各自完成的功能。</h3><p><strong>转发(forwarding):</strong> 将分组从路由器的输入端口转移到正确的路由器输出端口</p>
<p><strong>路由(routing):</strong> 确定分组从发送方传输到接收方(目的主机)所经过的路径(或路由)</p>
<p>类比:</p>
<p>路由: 类似于从发送方到接收方计划旅行路线的过程</p>
<p>转发: 类似于驾车通过一个立交桥的过程</p>
<p><strong>数据平面：</strong></p>
<ul>
<li>本地的，每个路由器自身的功能  </li>
<li>决定抵达路由器输入端口的数据包如何转发到输出端口</li>
</ul>
<p><strong>控制平面：</strong></p>
<ul>
<li><p>整个网络范围</p>
</li>
<li><p>决定数据报在端到端路径上的路由器之间如何路由</p>
</li>
<li><p>两种数据平面的实现方式：</p>
<ul>
<li><p>传统的路由算法: 在路由器内实现</p>
</li>
<li><p>软件定义网络（software-defined networking, SDN): 在远程服务器上实现</p>
</li>
</ul>
</li>
</ul>
<h3 id="路由器工作原理。"><a href="#路由器工作原理。" class="headerlink" title="路由器工作原理。"></a>路由器工作原理。</h3><p>路由器的两个核心功能</p>
<ul>
<li>运行路由算法&#x2F;协议(OSPF, RIP, BGP)</li>
<li>将分组从路由器的输入链路传送到正确的输出链路。</li>
</ul>
<p>路由器查表方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627003403.png" alt="QQ图片20230627003403"></p>
<p><strong>路由器的整体结构</strong></p>
<p><strong>输入端口</strong>：</p>
<p>线路端接模块：将一条物理链路端接到路由器的物理层；</p>
<p>数据链路处理模块：实现路由器的数据链路层功能；</p>
<p>查找与转发模块：实现查找与转发功能，以便分组通过路由器交换结构转发到适当的输出端口；如果数据报到达输入端口的速度快于输入端口将数据报转发到交换结构的速度，就会发生<strong>排队</strong>。</p>
<p><strong>选路处理器</strong>：计算转发表，给<strong>每个输入端口存放一份转发表拷贝</strong></p>
<p><strong>分布式交换</strong>：</p>
<p>（1）内存交换：选路处理器完成输入端口与输出端口之间的交换；交换速度受总线带宽的速度限制 (每个分组穿过两次总线)</p>
<p>（2）总线交换：输入端口通过一条<strong>共享总线</strong>将分组直接传送到输出端口，不需要选路处理器的干预;交换带宽受总线速率限制</p>
<p>（3）交换矩阵交换：到达输入端口的分组沿<strong>水平总线穿行</strong>，直至与所希望的<strong>输出端口的垂直总线交叉点</strong>，若该条垂直总线<strong>空闲</strong>，则分组被传送到输出端口，否则<strong>阻塞排队</strong>。</p>
<p><strong>输出端口</strong>：</p>
<ul>
<li>取出存放在输出端口内存中的分组，并将其传输到输出链路上；</li>
<li>当交换结构将分组交付给<strong>输出端口的速率超过输出链路速率</strong>，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</li>
</ul>
<h3 id="网际协议IP-：-IP报文、IP分片和重组、-IP编址和子网划分、-NAT网络地址转换、HDCP协议、IPV6的特点。"><a href="#网际协议IP-：-IP报文、IP分片和重组、-IP编址和子网划分、-NAT网络地址转换、HDCP协议、IPV6的特点。" class="headerlink" title="网际协议IP ： IP报文、IP分片和重组、 IP编址和子网划分、 NAT网络地址转换、HDCP协议、IPV6的特点。"></a>网际协议IP ： IP报文、IP分片和重组、 IP编址和子网划分、 NAT网络地址转换、HDCP协议、IPV6的特点。</h3><p>IP数据报分片和重组</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/04b7bcd6721fcd4ae62606d9722881a8.png" alt="img"></p>
<p><strong>IP地址</strong></p>
<ul>
<li><p>分配给主机或路由器接口的标识符</p>
<ul>
<li>主机&#x2F;路由器与物理链路之间的边界&#x2F;连接</li>
<li>路由器有多个接口，主机可以有多个接口</li>
</ul>
</li>
<li><p>IP地址有两种：IPV4和IPV6</p>
<ul>
<li><p>IPV4：32个二进制位长（4字节），常用<strong>点分十进制</strong>表示；将4个字节中的<strong>每一个字节分别用十进制数</strong>来表示，4个十进制数之间用 “.” 分隔。</p>
<p>例如：223.1.1.1 &#x3D; 11011111 00000001 00000001 00000001</p>
<p>根据不同的取值范围，早期将<strong>IP地址分为五类</strong>。IP地址中前5位用于标识IP地址的类别，A类地址的第一位为“0”（主机号24位），B类地址的前两位为“10”（主机号16位），C类地址的前三位为“110”（主机号8位），D类地址的前四位为“1110”，E类地址的前五位为“11110”。其中，A类、B类与C类地址为基本的IP地址。</p>
</li>
<li><p>IPV6：128个二进制位长（16字节）常用<strong>冒号分隔</strong>表示</p>
</li>
</ul>
</li>
</ul>
<p><strong>IP子网（subnet）</strong></p>
<ul>
<li>划分子网的方法是<strong>从主机号借用若干个比特作为子网号，剩下的主机位为主机号</strong>。</li>
<li>IP地址具有相同网络号的设备接口</li>
<li><strong>不跨越路由器</strong>（第三及以上层网络设备）可以<strong>彼此物理联通</strong>的接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/44599db7d2f16e8caafa50391bd08985.png" alt="img"></p>
<p>子网划分</p>
<p>分类的IP地址的弱点:</p>
<ul>
<li>lP地址空间的利用率有时很低。</li>
<li>两级lP地址不够灵活。</li>
</ul>
<p>网络号相同的IP地址属于同一个网络。而网络还可以划分为若干子网（subnet）。划分子网的方法是<strong>从主机号借用若干个比特作为子网号，剩下的主机位为主机号</strong>。在同一子网中，数据帧不跨越路由器，物理上能够相互到达。</p>
<p>为什么子网号能全0或者全1：因为CIDR编址<br>为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/413cc9984898ac570e7acc7aa691a4b2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/60a806d73c7fef6e82a6dacb8cc59a97.png" alt="img"></p>
<p>12、<strong>子网掩码</strong>用来确定网络地址（网络号+子网号）和主机地址的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网络号和子网号，而子网掩码中的0对应于主机号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/20313a8ce7ef57f57696f4453c0e08a4.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/c0119a8e01c60c5bcce17208959efd0c.png" alt="img"></p>
<p>虽然两个子网掩码得到的网络地址结果一样，但是后者的主机位更多，能容纳更多主机。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT:"></a>NAT:</h3><p> 执行NAT，路由器必须做到:</p>
<ul>
<li>外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)   远程客户&#x2F;服务器用(NAT IP地址, 新端口号)作为目的地来响应。</li>
<li>(在NAT转换表中)记录每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 转换配对</li>
<li>进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号）</li>
</ul>
<h4 id="DHCP协议："><a href="#DHCP协议：" class="headerlink" title="DHCP协议："></a>DHCP协议：</h4><p>（1）获得IP地址，还可以获得</p>
<ul>
<li>客户的第一跳路由器的地址（网关）</li>
<li>DNS服务器的IP地址或域名</li>
<li>子网掩码</li>
</ul>
<p>（2）<strong>DHCP是应用层协议</strong></p>
<ul>
<li>请求报文封装到UDP数据报中</li>
<li>IP广播</li>
<li>链路层广播 (e.g. 以太网广播)</li>
</ul>
<p>（3）报文种类</p>
<ul>
<li>主机广播 “DHCP DISCOVER” （发现报文）</li>
<li>DHCP 服务器用 “DHCP OFFER” （提供报文）进行响应</li>
<li>主机请求IP地址: “DHCP REQUEST” （请求报文）</li>
<li>DHCP 服务器分配IP地址 “DHCP ACK&#x2F;NACK” （确认报文）</li>
<li>DHCP 终止租用期”DHCP RELEASE”（终止报文）</li>
</ul>
<p>（4） DHCP 协议的工作过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/d5debbeb23390362a67973bfd56e02cb.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/c9898579eb7fc586f43b57bd709f8bb4.png" alt="img"></p>
<h4 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h4><ul>
<li>初始动机：32-bit IPv4地址空间即将用尽</li>
<li>其他动机：快速处理&#x2F;转发数据报；支持QoS（服务质量）</li>
<li>IPv6 数据报格式 ：固定长度的 40 字节基本首部 ；不允许分片</li>
</ul>
<h3 id="选路算法：链路状态选路算法、距离向量算法"><a href="#选路算法：链路状态选路算法、距离向量算法" class="headerlink" title="选路算法：链路状态选路算法、距离向量算法"></a>选路算法：链路状态选路算法、距离向量算法</h3><p><strong>链路状态选路算法</strong>（Dijkstra最低费用路径算法）：</p>
<p>术语定义</p>
<ul>
<li><p>c(x,y)：表示从节点x到y的链路费用;</p>
<p>&#x3D; ∞ 如果不是直接邻居</p>
</li>
<li><p>D(v)：表示从源节点到目的节点v的当前路径的费用；</p>
</li>
<li><p>p(v)：表示从源节点到目的节点v的路径上的前驱节点；</p>
</li>
<li><p>N’：表示已经找到最低费用路径的节点集合。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/65a0a519ba210751a860e8809cdb7396.png" alt="img"></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>N’</th>
<th>D(v),p(v)</th>
<th>D(w),p(w)</th>
<th>D(x),p(x)</th>
<th>D(y),p(y)</th>
<th>D(z),p(z)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>u</td>
<td>2，u</td>
<td>5，u</td>
<td>1，u</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>1</td>
<td>ux</td>
<td>2，u</td>
<td>4，x</td>
<td></td>
<td>2，x</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>uxy</td>
<td>2，u</td>
<td>3，y</td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>3</td>
<td>uxyv</td>
<td></td>
<td>3，y</td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>4</td>
<td>uxyvw</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>5</td>
<td>uxyvwz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>（有两个最小就随便选一个，此答案选的y）</p>
<p>根据<strong>目的节点找出顺序和其费用以及前驱节点</strong>，可以画出源节点u到所有目的节点的最低费用路径树。根据得到的所有目的节点的完整路径，或<strong>最低费用路径树</strong>，可以生成源节点的<strong>转发表</strong>。</p>
<p><strong>转发表</strong>：存放从源节点到每个目的节点的最低费用路径上的下一跳节点。即指出对于发往某个目的节点的分组，从该节点发出后的<strong>下一个节点</strong>。</p>
<p><strong>距离向量路由算法</strong>：</p>
<p>最低费用表示：</p>
<p>Bellman-Ford方程:</p>
<p>dx(y) &#x3D; minv{c(x,v)+ dv(y)}</p>
<p>dx(y)：节点x到节点y的最低费用路径的费用。</p>
<p>v: 节点x的邻居节点。</p>
<p>c(x,v)+ dv(y)：x与某个邻居v之间的直接链路费用c(x,v)加上邻居v到y的最小费用。即x经v到节点y的最小的路径费用。</p>
<p>minv ：从所有经直接相连邻居节点到节点y的费用中选取的最小路径费用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627004704.png" alt="QQ图片20230627004704"></p>
<h3 id="因特网中的层次选路协议"><a href="#因特网中的层次选路协议" class="headerlink" title="因特网中的层次选路协议"></a>因特网中的层次选路协议</h3><p>一个区域内的路由器组成集合 “自治系统” (AS，autonomous system )</p>
<p>同一个自治系统的路由器运行相同的路由协议——区域内路由协议</p>
<p>不同自治系统内的路由器可以运行不同的区域内路由协议</p>
<h2 id="第五章-链路层："><a href="#第五章-链路层：" class="headerlink" title="第五章 链路层："></a>第五章 <strong>链路层</strong>：</h2><h3 id="差错检测方法，三种差错检测的计算方法、他们的各自的特定和使用范围。"><a href="#差错检测方法，三种差错检测的计算方法、他们的各自的特定和使用范围。" class="headerlink" title="差错检测方法，三种差错检测的计算方法、他们的各自的特定和使用范围。"></a>差错检测方法，三种差错检测的计算方法、他们的各自的特定和使用范围。</h3><p>奇偶校验：最基本的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005058.png" alt="QQ图片20230627005058"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005136.png" alt="QQ图片20230627005136"></p>
<p>Internet校验和：常用于运输层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005354.png" alt="QQ图片20230627005354"></p>
<p>循环冗余检测：常用于链路层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005430.png" alt="QQ图片20230627005430"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005532.png" alt="QQ图片20230627005532"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005559.png" alt="QQ图片20230627005559"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627005700.png" alt="QQ图片20230627005700"></p>
<p>CRC特点：   能检测小于 r+1 位的突发差错、任何奇数个差错。</p>
<h3 id="多路访问链路和协议：三种主要的多路访问协议各自的特点。"><a href="#多路访问链路和协议：三种主要的多路访问协议各自的特点。" class="headerlink" title="多路访问链路和协议：三种主要的多路访问协议各自的特点。"></a>多路访问链路和协议：三种主要的多路访问协议各自的特点。</h3><ul>
<li>信道划分协议<ul>
<li>把信道划分为小“片” (时隙)</li>
<li>给节点分配专用的小“片”</li>
</ul>
</li>
<li>随机访问协议<ul>
<li>不划分信道，允许冲突</li>
<li>能从冲突中“恢复”</li>
</ul>
</li>
<li>轮流协议<ul>
<li>通过轮流访问信道避免冲突，要发送的节点越多轮流时间越长</li>
</ul>
</li>
</ul>
<h3 id="以太网技术-链路层和物理层的实现方式"><a href="#以太网技术-链路层和物理层的实现方式" class="headerlink" title="以太网技术(链路层和物理层的实现方式"></a>以太网技术(链路层和物理层的实现方式</h3><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627010011.png"></p>
<h4 id="以太网提供无连接、不可靠的服务-以太网采用的CSMA-CD原理"><a href="#以太网提供无连接、不可靠的服务-以太网采用的CSMA-CD原理" class="headerlink" title="以太网提供无连接、不可靠的服务&amp;以太网采用的CSMA&#x2F;CD原理"></a>以太网提供无连接、不可靠的服务&amp;以太网采用的CSMA&#x2F;CD原理</h4><p><em><strong>以太网: 不可靠的无连接服务</strong></em></p>
<p>以太网向网络层提供的服务。</p>
<ul>
<li>无连接服务：通信时，<strong>发送方适配器不需要先和接收方适配器“握手”</strong>。</li>
<li>不可靠的服务：接收到的帧可能包含比特差错。<ul>
<li>收到正确帧，<strong>不发确认帧</strong>；</li>
<li>收到出错帧，丢弃该帧，<strong>不发否定帧</strong>。</li>
<li>发送适配器不会重发出错帧。</li>
<li>丢弃数据的恢复是通过终端<strong>传输层</strong>的可靠数据传输机制来实现的</li>
</ul>
</li>
<li>以太网的MAC协议：<strong>使用无时隙的CSMA&#x2F;CD协议（二进制指数回退）</strong></li>
</ul>
<h3 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h3><p>ARP: 地址解析协议：将IP地址解析到MAC地址。</p>
<p>ARP只为在同一个LAN上的节点解析IP地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/QQ%E5%9B%BE%E7%89%8720230627010354.png" alt="QQ图片20230627010354"></p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机：支持多节点同时传输</p>
<ul>
<li>每个主机由单独的链路直接连到交换机端口</li>
<li>交换机可以缓存数据帧</li>
<li>以太网协议在每个输入链路使用，无碰撞，全双工</li>
<li>每条链路自身是一个碰撞域</li>
<li>交换机： A-to-A‘和B-to-B’可以同时传输，而不会发生碰撞</li>
</ul>
<p>交互机：自学习</p>
<p>交换机会学习通过哪些端口可以到达哪些主机</p>
<ul>
<li>当收到数据帧时，交换机“学习”发送主机的位置：进入的局域网网段(到达端口)</li>
<li>在转发表中记录发送主机&#x2F;位置对</li>
</ul>
<p>当交换机收到数据帧:</p>
<ol>
<li><p>记录到达链路和发送主机的MAC地址</p>
</li>
<li><p>使用数据帧的目的MAC地址，在转发表中检索</p>
</li>
<li><p>如果在转发表条目中找到对应的MAC地址</p>
</li>
<li><p>执行{</p>
<p>​	如果 目的MAC地址对应的端口与数据帧的达到端口相同	</p>
<p>​    则 丢弃该数据帧	</p>
<p>​    否则 转发该数据帧到条目指定的端口</p>
</li>
<li><p>}</p>
</li>
<li><p>否则，向除到达端口之外的所有端口转发(flood)</p>
</li>
</ol>
<h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p>含义：利用支持VLAN的交换机，可以在一个实际的物理局域网内，定义多个虚拟的局域网。</p>
<p><strong>基于端口的VLAN</strong>:</p>
<ul>
<li>利用交换机内置的管理软件，将端口分组，使得一个单独的交换机，像多个交换机那样工作</li>
</ul>
<p><strong>跨越多个交换机的 VLAN</strong></p>
<ul>
<li>干线端口（ trunk port ）承载定义在多个物理交换机之上的VLAN间的流量</li>
<li>某一个VLAN内的流量帧，如果要跨域物理的交换机，需使用802.1q格式（带有VLAN ID 信息）802.1q协议的作用：对干线端口之间传输的帧，添加&#x2F;移除额外的头部字段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kkirito16/picgopicture/img/f917eb082d83f7a3d6121eaa0e2c929b.png" alt="img"></p>
]]></content>
      <categories>
        <category>复习资料</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习总结</title>
    <url>/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统期末复习"><a href="#操作系统期末复习" class="headerlink" title="操作系统期末复习"></a>操作系统期末复习</h1><h2 id="1、进程和线程的概念"><a href="#1、进程和线程的概念" class="headerlink" title="1、进程和线程的概念"></a>1、进程和线程的概念</h2><h3 id="典型的进程定义有："><a href="#典型的进程定义有：" class="headerlink" title="典型的进程定义有："></a>典型的进程定义有：</h3><p>（1）进程是程序的一次执行。（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。（3）进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<h2 id="2、进程的基本状态及状态转换的原因"><a href="#2、进程的基本状态及状态转换的原因" class="headerlink" title="2、进程的基本状态及状态转换的原因"></a>2、进程的基本状态及状态转换的原因</h2><p><img src="https://pic.imgdb.cn/item/64d8c2e01ddac507cc26b93a.png"></p>
<h3 id="状态转换："><a href="#状态转换：" class="headerlink" title="状态转换："></a>状态转换：</h3><p> ① 空 -&gt;新状态  新创建的进程首先处于新状态。 </p>
<p>② 新状态 -&gt;就绪状态  当系统允许增加就绪进程时，操作系统接纳新建状态进程，将它变为就绪状态，插入就绪队列中。 </p>
<p>③ 就绪状态 -&gt; 执行状态  当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为进程调度，或将处理机分派给一个进程，该进程状态从就绪转变为执行。 </p>
<p>④ 执行状态 -&gt; 终止状态  执行状态的进程执行完毕，或出现诸如访问地址越界、非法指令等错误，而被异常结束，则进程从执行状态转换为终止状态。</p>
<p>⑤ 执行状态 -&gt; 就绪状态  分时系统中，时间片用完，或优先级高的进程到来，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。</p>
<p>⑥ 执行状态 -&gt; 阻塞状态  执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待I&#x2F;O操作、等待另一进程与之通信等事件而阻塞。</p>
<p>⑦ 阻塞状态 -&gt; 就绪状态  当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队，等待被调度执行。</p>
<h2 id="3-PCB的作用"><a href="#3-PCB的作用" class="headerlink" title="3.PCB的作用"></a>3.PCB的作用</h2><p>进程控制块：进程控制块的作用是使一个在多道程序环境下不能独立运行的程序（包含数据），成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</p>
<h2 id="4-进程控制的原语操作"><a href="#4-进程控制的原语操作" class="headerlink" title="4.进程控制的原语操作"></a>4.进程控制的原语操作</h2><h3 id="（1）进程的创建原语"><a href="#（1）进程的创建原语" class="headerlink" title="（1）进程的创建原语"></a>（1）进程的创建原语</h3><p>调用进程创建原语Create（  ）按下述步骤创建一个新进程</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic.imgdb.cn/item/64d8c3d91ddac507cc28a180.png"></h4><h3 id="2-进程的终止原语"><a href="#2-进程的终止原语" class="headerlink" title="(2)进程的终止原语"></a>(2)进程的终止原语</h3><p>正常结束:  </p>
<p>批处理中用Holt指令，分时中用Logs off指令</p>
<p><img src="https://img-blog.csdnimg.cn/20200315164109198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70"></p>
<h3 id="（3）进程的唤醒和阻塞原语"><a href="#（3）进程的唤醒和阻塞原语" class="headerlink" title="（3）进程的唤醒和阻塞原语"></a>（3）进程的唤醒和阻塞原语</h3><p><img src="https://pic.imgdb.cn/item/64d8c4091ddac507cc290135.png"></p>
<h3 id="引起进程阻塞的事件"><a href="#引起进程阻塞的事件" class="headerlink" title="引起进程阻塞的事件:"></a>引起进程阻塞的事件:</h3><p>(1）请求系统服务：提出I&#x2F;O服务时，并不立即满足该进程的要求时，转变为阻塞状态来等待</p>
<p>(2）启动某种操作：当进程启动某种操作后，在该操作完成之后才能继续执行</p>
<p>(3）新数据尚未到达：对于相互合作的进程而言。</p>
<p> (4）无新工作可做。如发送进程</p>
<h3 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程:"></a>进程阻塞过程:</h3><p>(1)正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block( )把自己阻塞</p>
<p>(2)把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列</p>
<p>(3)转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换</p>
<h3 id="进程唤醒过程："><a href="#进程唤醒过程：" class="headerlink" title="进程唤醒过程："></a>进程唤醒过程：</h3><p>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I&#x2F;O设备的进程）调用唤醒原语wakeup（  ），将等待该事件的进程唤醒</p>
<h3 id="4-进程的挂起和激活过程"><a href="#4-进程的挂起和激活过程" class="headerlink" title="(4)进程的挂起和激活过程"></a>(4)进程的挂起和激活过程</h3><p><img src="https://pic.imgdb.cn/item/64d8c4351ddac507cc295969.png"></p>
<h2 id="5-进程互斥、临界区、进程同步的基本概念、同步准则"><a href="#5-进程互斥、临界区、进程同步的基本概念、同步准则" class="headerlink" title="5.进程互斥、临界区、进程同步的基本概念、同步准则"></a>5.进程互斥、临界区、进程同步的基本概念、同步准则</h2><h3 id="进程互斥："><a href="#进程互斥：" class="headerlink" title="进程互斥："></a>进程互斥：</h3><p>进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。</p>
<h3 id="临界资源："><a href="#临界资源：" class="headerlink" title="临界资源："></a>临界资源：</h3><p>一次仅允许一个进程访问的资源为临界资源 。</p>
<h3 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h3><p>把在每个进程中访问临界资源的那段代码称为临界区。</p>
<h3 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h3><p>进程同步是一个操作系统级别的概念，是在多道程序的环境下，存在着不同的制约关系，为了协调这种互相制约的关系，实现资源共享和进程协作，从而避免进程之间的冲突，引入了进程同步。</p>
<p>进程同步的主要任务：是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
<h3 id="同步准则："><a href="#同步准则：" class="headerlink" title="同步准则："></a>同步准则：</h3><p>1)空闲让进</p>
<p>2)忙则等待</p>
<p>3)有限等待</p>
<p>4)让权等待</p>
<h2 id="6-记录型信号量"><a href="#6-记录型信号量" class="headerlink" title="6.记录型信号量"></a>6.记录型信号量</h2><p>记录型信号量机制，则是一种不存在“忙等”现象的进程同步机制</p>
<p>记录型信号量的数据结构: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type  semaphore = record</span><br><span class="line">                  value  ：integer；</span><br><span class="line">                  L：list  of  process；</span><br><span class="line"> end  </span><br></pre></td></tr></table></figure>

<p>记录型信号量的wait（S）操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure  wait（  S  ）</span><br><span class="line">    var  S：  semaphore；</span><br><span class="line">       begin   </span><br><span class="line">           S.value:＝S.value-1;</span><br><span class="line">           if  S.value＜0  then  block（S.L）;</span><br><span class="line">       end</span><br><span class="line">// S.value＜0，该类资源已经分配完毕，进程必须放弃处理机，自我阻塞。</span><br></pre></td></tr></table></figure>

<p>记录型信号量的signal（S）操作:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure  signal（S）</span><br><span class="line">  var  S:semaphore； </span><br><span class="line">  begin</span><br><span class="line">      S.value:＝S.value+1；</span><br><span class="line">      if  S.value≤0  then   wakeup(S.L)；</span><br><span class="line">  end</span><br><span class="line">// S.value≤0 ，在信号量链表中，仍有等待该资源的进程被阻塞。</span><br></pre></td></tr></table></figure>

<h2 id="7-信号量的应用"><a href="#7-信号量的应用" class="headerlink" title="7.信号量的应用"></a>7.信号量的应用</h2><ol>
<li><h3 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h3></li>
</ol>
<p>为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait（mutex）和signal（mutex）操作之间即可。</p>
<p>利用信号量实现进程互斥的进程可描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Var  mutex：semaphore:=1；</span><br><span class="line">          begin</span><br><span class="line">          parbegin</span><br><span class="line"></span><br><span class="line">             process1：begin</span><br><span class="line">                 repeat</span><br><span class="line">                      wait（mutex）；</span><br><span class="line">                      critica1  section</span><br><span class="line">                      signal（mutex）；</span><br><span class="line">                     remainder  section  until false;</span><br><span class="line">             end</span><br><span class="line">             process2：begin</span><br><span class="line">                        repeat</span><br><span class="line">                            wait（mutex）;</span><br><span class="line">                            critical  section</span><br><span class="line">                            signal（mutex）;</span><br><span class="line">                            remainder section until false；</span><br><span class="line">              end</span><br><span class="line">   parend </span><br><span class="line">   end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wait（mutex）和signal（mutex）必须成对出现；</p>
<p>缺少wait（mutex）导致系统混乱，不能保证对临界资源的互斥访问；</p>
<p>缺少signal（mutex）会使临界资源永远不释放，等待该资源的进程不能被唤醒。</p>
<h3 id="2-利用信号量实现前趋关系"><a href="#2-利用信号量实现前趋关系" class="headerlink" title="2.利用信号量实现前趋关系"></a>2.利用信号量实现前趋关系</h3><p><img src="https://pic.imgdb.cn/item/64d8c4351ddac507cc2959b5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p1( )&#123; S1； signal（a）；signal（b）；&#125;</span><br><span class="line">p2( )&#123; wait(a); S2；signal（c）；signal（d）; &#125;</span><br><span class="line">p3( )&#123; wait（b）；S3；signal（e）；&#125;</span><br><span class="line">p4( )&#123; wait（c）；S4；signal（f）；&#125;</span><br><span class="line">p5( )&#123; wait（d）；S5；signal（g）；&#125;</span><br><span class="line">p6( )&#123; wait（e）；wait（f）；wait（g）；S6；&#125;</span><br><span class="line"></span><br><span class="line">void main( )&#123;</span><br><span class="line">    semaphore a,b,c,d,e,f,g;</span><br><span class="line">    a.value=b.value=c.value=0;</span><br><span class="line">    d.value=e.value=f.value=g.value=0;</span><br><span class="line">    cobegin</span><br><span class="line">         p1( ); p2( ); p3( ); p4( ); p5( ); p6( );</span><br><span class="line">    coend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-经典进程同步问题；生产者与消费者问题"><a href="#8-经典进程同步问题；生产者与消费者问题" class="headerlink" title="8.经典进程同步问题；生产者与消费者问题"></a>8.经典进程同步问题；生产者与消费者问题</h2><p>生产者和消费者进程共享一个大小固定的缓冲区，其中，一个或多个生产者生产数据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。 </p>
<p>假设缓冲区的大小为n（存储单元的个数），它可以被生产者和消费者循环使用</p>
<p>分别设置两个指针in和out，指向生产者将存放数据的存储单元和消费者将取数据的存储单元，如图</p>
<p><img src="https://pic.imgdb.cn/item/64d8c4341ddac507cc29582e.png"></p>
<p><img src="C:\Users\10410\Desktop\操作系统期末复习\image-20230616160458024.png" alt="image-20230616160458024"></p>
<p><img src="https://pic.imgdb.cn/item/64d8c2c31ddac507cc267c42.png"></p>
<h3 id="1-利用记录型信号量解决生产者一消费者问题"><a href="#1-利用记录型信号量解决生产者一消费者问题" class="headerlink" title="1.利用记录型信号量解决生产者一消费者问题"></a>1.利用记录型信号量解决生产者一消费者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> int  in=0, out=0;</span><br><span class="line"> item    buffer [n];</span><br><span class="line"> semaphore	mutex=1, empty=n, full=0;   </span><br><span class="line"> </span><br><span class="line">void producer( );</span><br><span class="line">void consumer( );</span><br><span class="line"></span><br><span class="line">void main( )&#123;</span><br><span class="line">      cobegin</span><br><span class="line">             producer( ); consumer( );</span><br><span class="line">      coend</span><br><span class="line">&#125;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">      			…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">              		…</span><br><span class="line">wait(empty);</span><br><span class="line">wait(mutex);</span><br><span class="line">buffer(in):=nextp;</span><br><span class="line">in:=(in+1) mod n;</span><br><span class="line">signal(mutex);</span><br><span class="line">signal(full);</span><br><span class="line">&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">	      wait(full);</span><br><span class="line">wait(mutex);</span><br><span class="line">nextc:=buffer(out);</span><br><span class="line">out:=(out+1) mod n;</span><br><span class="line">signal(mutex);</span><br><span class="line">signal(empty);</span><br><span class="line">Consumer the item in nextc;</span><br><span class="line">     ……</span><br><span class="line">&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-利用AND信号量解决生产者—消费者问题"><a href="#2-利用AND信号量解决生产者—消费者问题" class="headerlink" title="2.利用AND信号量解决生产者—消费者问题"></a>2.利用AND信号量解决生产者—消费者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  int  in=0, out=0;</span><br><span class="line">  item    buffer[ n ];</span><br><span class="line">  semaphore   mutex=1;</span><br><span class="line">  semaphore  empty=n, full=0;</span><br><span class="line"></span><br><span class="line">  void producer( )&#123;</span><br><span class="line">       do&#123;</span><br><span class="line">			…</span><br><span class="line">		 produce an item in nextp;</span><br><span class="line">			…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">		buffer[in] = nextp;</span><br><span class="line"> in = (in+1) % n;</span><br><span class="line">   Ssignal(mutex, full);</span><br><span class="line">      &#125;while(TRUE);</span><br><span class="line">   &#125; //end producer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">	   Swait(full, mutex);</span><br><span class="line">	   nextc = buffer[out];</span><br><span class="line">	   out = (out+1) % n;</span><br><span class="line">	   Ssignal(mutex, empty);</span><br><span class="line">	   consumer the item in nextc;</span><br><span class="line">     &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-进程间通信的原理和实现方法-信箱"><a href="#9-进程间通信的原理和实现方法-信箱" class="headerlink" title="9.进程间通信的原理和实现方法   信箱"></a>9.进程间通信的原理和实现方法   信箱</h2><h3 id="进程间通信的原理和实现方法"><a href="#进程间通信的原理和实现方法" class="headerlink" title="进程间通信的原理和实现方法"></a>进程间通信的原理和实现方法</h3><h4 id="1-共享存储器系统"><a href="#1-共享存储器系统" class="headerlink" title="1.共享存储器系统"></a>1.共享存储器系统</h4><p>（1）基于共享数据结构的通信方式。  （2）基于共享存储区的通信方式。 </p>
<h4 id="2-消息传递系统"><a href="#2-消息传递系统" class="headerlink" title="2.消息传递系统"></a>2.消息传递系统</h4><p>是目前的主要通信方式，信息单位：消息（报文）实现：一组通信命令（原语），具有透明性-&gt;同步的实现。     </p>
<p>实现方式的不同，而分成:（1）直接通信方式   （2）间接通信方式</p>
<h4 id="3-管道（Pipe）通信"><a href="#3-管道（Pipe）通信" class="headerlink" title="3.管道（Pipe）通信"></a>3.管道（Pipe）通信</h4><p>管道：连接一个读进程和一个写进程之间通信的共享文件。</p>
<p>功能：大量的数据发收。注意：（1）互斥（2）同步 （3）对方是否存在</p>
<h3 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h3><h4 id="1-直接通信方式"><a href="#1-直接通信方式" class="headerlink" title="1.直接通信方式"></a>1.直接通信方式</h4><p> 这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。系统提供下述两条通信命令（原语）：     </p>
<p>Send  （Receiver，  message）；     </p>
<p>Receive（Sender，  message）；</p>
<h4 id="2-间接通信方式"><a href="#2-间接通信方式" class="headerlink" title="2.间接通信方式"></a>2.间接通信方式</h4><p>指进程之间利用信箱的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。     系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。 </p>
<p>优点：在读&#x2F;写时间上的随机性写进程 -&gt;信箱（中间实体）-&gt;读进程原语</p>
<p>消息的发送和接收</p>
<p>Send (mailbox, message)</p>
<p>Receive (mailbox, message)</p>
<h3 id="信箱"><a href="#信箱" class="headerlink" title="信箱"></a>信箱</h3><p>信箱分为以下三类：</p>
<p>（1）私用信箱（2）公用信箱（3）共享信箱</p>
<p>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：</p>
<p>（1）一对一关系。 （2）多对一关系，客户&#x2F;服务器交互。 （3）一对多关系， 广播方式。（4）多对多关系。  </p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h2 id="10-重定位的基本概念：为什么要引入"><a href="#10-重定位的基本概念：为什么要引入" class="headerlink" title="10.重定位的基本概念：为什么要引入"></a>10.重定位的基本概念：为什么要引入</h2><p>为解决链接地址跟运行地址不同的问题。</p>
<p>装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。</p>
<h2 id="11-如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享"><a href="#11-如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享" class="headerlink" title="11.如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享"></a>11.如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享</h2><h3 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h3><h4 id="离散分配方式的引入："><a href="#离散分配方式的引入：" class="headerlink" title="离散分配方式的引入："></a>离散分配方式的引入：</h4><p>连续分配方式会产生内&#x2F;外零头</p>
<p>为解决零头问题又要进行紧凑等高开销活动</p>
<h4 id="什么是离散分配："><a href="#什么是离散分配：" class="headerlink" title="什么是离散分配："></a>什么是离散分配：</h4><p> 程序在内存中不一定连续存放</p>
<h4 id="离散分配的体现"><a href="#离散分配的体现" class="headerlink" title="离散分配的体现:"></a>离散分配的体现:</h4><p>内存一块可以装入程序一页连续的多个页不一定装入连续的多个块中注：系统中页块的大小是不变的。</p>
<h3 id="离散分配的优点："><a href="#离散分配的优点：" class="headerlink" title="离散分配的优点："></a>离散分配的优点：</h3><p>没有外零头不受连续空间限制，每块都能分出去仅有小于一个页面的内零头</p>
<p>程序大小一般不是页大小的整数倍        </p>
<p>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”或称为“内零头”。 </p>
<h2 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h2><p>对换指把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存。 </p>
<p>对换是系统行为，是提高内存的利用率的有效措施。常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。 </p>
<h3 id="对换的实现："><a href="#对换的实现：" class="headerlink" title="对换的实现："></a>对换的实现：</h3><p>可在系统中设一对换进程，以执行换进内存、换出至外存操作。</p>
<h3 id="对换的分类："><a href="#对换的分类：" class="headerlink" title="对换的分类："></a>对换的分类：</h3><h4 id="“整体对换”（进程对换）："><a href="#“整体对换”（进程对换）：" class="headerlink" title="“整体对换”（进程对换）："></a>“整体对换”（进程对换）：</h4><p>对换以整个进程为单位，用于分时系统，以解决内存紧张的问题；</p>
<h4 id="“页面对换-分段对换”："><a href="#“页面对换-分段对换”：" class="headerlink" title="“页面对换&#x2F;分段对换”："></a>“页面对换&#x2F;分段对换”：</h4><p>对换以“页”或“段”为单位进行“部分对换”，该方法是实现请求分页及请求分段存储器的基础，支持虚存系统。</p>
<p>为实现对换，系统需要三方面的功能：对换空间的管理、进程的换入、进程的换出</p>
<h4 id="对换空间的管理："><a href="#对换空间的管理：" class="headerlink" title="对换空间的管理："></a>对换空间的管理：</h4><p>外存被分为两部分，文件区和对换区</p>
<p>文件区用于存放文件，对它的管理应重在如何提高存储空间的利用率。所以对它采取离散分配方式。</p>
<p>对换区存放从内存换出的进程，它们在外存的存放时间较短，换入、换出频繁。对对换区的管理应重在提高进程的换入换出速度。因此采用连续分配方式。</p>
<p>为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况</p>
<p>空闲分区表或空闲分区链。基本单位都是盘块</p>
<p>对换区的分配采用连续分配方式，分配与回收与动态分区方式时内存的分配与回收方法雷同</p>
<h4 id="进程的换出与换入："><a href="#进程的换出与换入：" class="headerlink" title="进程的换出与换入："></a>进程的换出与换入：</h4><h5 id="换出（swap-out）"><a href="#换出（swap-out）" class="headerlink" title="换出（swap out）"></a>换出（swap out）</h5><p>选择：首先选择阻塞或睡眠状态的进程，若有多个，按优先级由低到高进行选择。若没有此状态进程，则选择就绪状态的，仍然按优先级由低到高进行选择。为避免某进程被频繁的换入换出，还应考虑进程在内存中的驻留时间，优先选择驻留时间长的进程。</p>
<h5 id="换入（swap-in）"><a href="#换入（swap-in）" class="headerlink" title="换入（swap in）"></a>换入（swap in）</h5><p>①从 PCB集合中查找“就绪且换出”的进程，有多个，则选择换出时间最长的。</p>
<p>②根据进程大小申请内存，成功则读入，否则要先执行换出，再换入。</p>
<p>③若还有可换入进程，则转向①。直至无“就绪且换出”进程或无法获得足够内存空间为止。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h4 id="与之相对的静态链接："><a href="#与之相对的静态链接：" class="headerlink" title="与之相对的静态链接："></a>与之相对的<strong>静态链接</strong>：</h4><p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。</p>
<h3 id="装入时动态链接："><a href="#装入时动态链接：" class="headerlink" title="装入时动态链接："></a>装入时动态链接：</h3><p>用户源程序经编译后所得到的目标模块，是在装入内存时，边装入边链接的。即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。        </p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>便于软件版本的修改和更新。只需修改各个目标模块，不必将装入模块拆开，非常方便。        </li>
<li>便于实现目标模块共享。即可以将一个目标模块链接到几个应用模块中，从而实现多个应用程序对该模块的共享。</li>
</ol>
<h3 id="运行时动态链接-Run-Time-Dynamic-Linking）："><a href="#运行时动态链接-Run-Time-Dynamic-Linking）：" class="headerlink" title="运行时动态链接(Run-Time Dynamic Linking）："></a>运行时动态链接(Run-Time Dynamic Linking）：</h3><p>将某些目标模块的链接推迟到执行时才进行，即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并链接到调用模块上。</p>
<p>优点：执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，不仅可加快程序的装入过程，而且可节省大量的内存空间</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h4 id="虚拟存储器："><a href="#虚拟存储器：" class="headerlink" title="虚拟存储器："></a>虚拟存储器：</h4><p>是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<h4 id="程序执行的局部性原理："><a href="#程序执行的局部性原理：" class="headerlink" title="程序执行的局部性原理："></a>程序执行的局部性原理：</h4><p>程序的执行总是呈现局部性。即，在一个较短的时间段内，程序的执行仅限于某个部分；相应的，它所访问的存储空间也局限于某个区域。因此，只要保证进程执行所需的部分程序和数据驻留在内存，一段时间内进程都能顺利执行</p>
<p>局限性又表现在下述两个方面：</p>
<h3 id="1-时间局限性"><a href="#1-时间局限性" class="headerlink" title="(1) 时间局限性"></a>(1) 时间局限性</h3><p>如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</p>
<h3 id="2-空间局限性"><a href="#2-空间局限性" class="headerlink" title="(2) 空间局限性"></a>(2) 空间局限性</h3><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行</p>
<h3 id="虚拟存储器的基本工作情况"><a href="#虚拟存储器的基本工作情况" class="headerlink" title="虚拟存储器的基本工作情况"></a>虚拟存储器的基本工作情况</h3><p>1）基于局部性原理。一个作业运行前，仅将那些当前要运行的页面（段）装入内存启动运行，其余暂在外存。</p>
<p>2）若运行所需页面（段）不在内存，则利用请求调页（段）功能将其调入内存。</p>
<p>3）若此时内存满，则利用置换功能，将内存中暂时不用的部分页面（段）调至外存，再将所需页面（段）调入。</p>
<p>4）这样，可实现大程序在小内存中运行，也可实现内存中同时装入更多的进程并发执行。</p>
<h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><h4 id="一、请求分页系统"><a href="#一、请求分页系统" class="headerlink" title="一、请求分页系统"></a>一、请求分页系统</h4><p>它是在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。</p>
<p>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：        </p>
<ol>
<li>请求分页的页表机制。        </li>
<li>缺页中断机构。        </li>
<li>地址变换机构。</li>
</ol>
<p>此外，实现请求调页、页面置换两大功能还需得到OS的支持。</p>
<h4 id="二、请求分段系统"><a href="#二、请求分段系统" class="headerlink" title="二、请求分段系统"></a>二、请求分段系统</h4><p>它是在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。        </p>
<p>为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：        </p>
<ol>
<li>请求分段的段表机制。        </li>
<li>缺段中断机构。        </li>
<li>地址变换机构。</li>
</ol>
<p>此外，实现请求调段、分段置换两大功能还需得到OS的支持。</p>
<h4 id="三、段页式虚拟系统"><a href="#三、段页式虚拟系统" class="headerlink" title="三、段页式虚拟系统"></a>三、段页式虚拟系统</h4><p>目前，许多虚拟存储管理系统是建立在段页式系统的基础上的，通过增加了请求调页、页面置换两大功能所形成的段页式虚拟存储系统。</p>
<h2 id="12-动态分区分配方式：分配、回收算法"><a href="#12-动态分区分配方式：分配、回收算法" class="headerlink" title="12.动态分区分配方式：分配、回收算法"></a>12.动态分区分配方式：分配、回收算法</h2><p>动态分区分配（可重定位分区分配）是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的</p>
<p>分区的数目固定大小是可变的，允许分区的数目和大小都是可变的。</p>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法:"></a>分区分配算法:</h3><p><img src="https://pic.imgdb.cn/item/64d8c2c71ddac507cc2683c7.png"></p>
]]></content>
      <categories>
        <category>复习资料</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
